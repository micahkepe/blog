<!doctype html>
<html lang="en">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />

    <!-- Enable responsiveness on mobile devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    
      
        
        <meta name="description" content="In a little over 100 lines of Rust code, we can build a simple shell program
that can execute commands, supports piping, handles signals, and maintains
command history. This tutorial will guide you through the process of creating
a minimal shell, which we will call &quot;minishell&quot;, using Rust&#x27;s powerful standard
library and some external crates." />
        <meta property="og:description" content="In a little over 100 lines of Rust code, we can build a simple shell program
that can execute commands, supports piping, handles signals, and maintains
command history. This tutorial will guide you through the process of creating
a minimal shell, which we will call &quot;minishell&quot;, using Rust&#x27;s powerful standard
library and some external crates." />
        <meta property="twitter:description" content="In a little over 100 lines of Rust code, we can build a simple shell program
that can execute commands, supports piping, handles signals, and maintains
command history. This tutorial will guide you through the process of creating
a minimal shell, which we will call &quot;minishell&quot;, using Rust&#x27;s powerful standard
library and some external crates." />
      
    

    <!-- Title -->
    
      
    
    <title>
    
    Let&#x27;s Build a (Mini)Shell in Rust
    
</title>

    <!-- Additional Facebook Meta Tags -->
    <meta property="og:site_name" content="Micah&#x27;s Secret Blog" />
    <meta
      property="og:url"
      content="https:&#x2F;&#x2F;micahkepe.com&#x2F;blog&#x2F;minishell&#x2F;"
    />
    <meta
      property="og:type"
      content="article"
    />
    <meta property="og:title" content="Let&#x27;s Build a (Mini)Shell in Rust" />

    <!-- Additional Twitter Meta Tags -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta
      property="twitter:url"
      content="https:&#x2F;&#x2F;micahkepe.com&#x2F;blog&#x2F;minishell&#x2F;"
    />
    <meta name="twitter:title" content="Let&#x27;s Build a (Mini)Shell in Rust" />

    <!-- Additional Fediverse Tags -->
     

    <!-- Cover images -->
    
    

    <meta
      property="og:image"
      content="https:&#x2F;&#x2F;micahkepe.com&#x2F;blog&#x2F;icons&#x2F;favicon&#x2F;web-app-manifest-512x512.png"
    />

    <meta
      name="twitter:image"
      content="https:&#x2F;&#x2F;micahkepe.com&#x2F;blog&#x2F;icons&#x2F;favicon&#x2F;web-app-manifest-512x512.png"
    />



    <!-- Favicons -->
    
    <link
      rel="icon"
      type="image/png"
      href="https:&#x2F;&#x2F;micahkepe.com&#x2F;blog/icons/favicon/favicon-96x96.png"
      sizes="96x96"
    />
    <link
      rel="icon"
      type="image/svg+xml"
      href="https:&#x2F;&#x2F;micahkepe.com&#x2F;blog/icons/favicon/favicon.svg"
    />
    <link
      rel="shortcut icon"
      href="https:&#x2F;&#x2F;micahkepe.com&#x2F;blog/icons/favicon/favicon.ico"
    />
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="https:&#x2F;&#x2F;micahkepe.com&#x2F;blog/icons/favicon/apple-touch-icon.png"
    />
    <meta name="apple-mobile-web-app-title" content="Let&#x27;s Build a (Mini)Shell in Rust" />
    <link
      rel="manifest"
      href="https:&#x2F;&#x2F;micahkepe.com&#x2F;blog/icons/favicon/site.webmanifest"
    />
    

    <!-- RSS Feed -->
    
    <link
      rel="alternate"
      type="application/atom+xml"
      title="RSS"
      href="https://micahkepe.com/blog/atom.xml"
    />
    

    <!-- Load Styles -->
    


      <link
        rel="stylesheet"
        href="https://micahkepe.com/blog/site.css"
      />
    

<!-- Custom styling -->
<link
  rel="stylesheet"
  href="https://micahkepe.com/blog/custom.css"
/>



    <!-- Load Fonts -->
    

  






  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400&display=swap" rel="stylesheet">
  
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@700&display=swap" rel="stylesheet">
  



<!-- Forcing Font -->
<style>
body {
  font-family:
    "JetBrains Mono", Menlo, Monaco, Lucida Console, Liberation Mono,
    DejaVu Sans Mono, Bitstream Vera Sans Mono, Courier New,
    monospace, serif !important;
}
</style>


    <!-- Pass Theme Preference as Data Attribute -->
    <script src="https://micahkepe.com/blog/js/init-theme.js"></script>

    <!-- Reference return to click position script -->
    <script defer src="https://micahkepe.com/blog/js/reference-return.js"></script>

    <!-- Additional scripts -->
    
      
        <script defer src="https://micahkepe.com/blog/js/codeblock.js"></script>
      
      
        <script src="https://micahkepe.com/blog/js/toggle-theme.js"></script>
      
      
<!-- MathJax script for rendering LaTeX math equations -->
<script src="https://micahkepe.com/blog/js/mathjax-config.js"></script>
<script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"
  async
></script>


      
<script type="text/javascript" src="https://micahkepe.com/blog/elasticlunr.min.js"></script>
<script type="text/javascript" src="https://micahkepe.com/blog/js/search.js"></script>

    
  </head>

  <!-- Body element (contents of the page) -->
  <body class="hack main container">
    

  
    
    
      
  
  <section class="nav-header">
    <nav
      itemscope
      itemtype="http://schema.org/SiteNavigationElement"
      class="navbar"
    >
      <section class="nav-links">
        
        <a
          itemprop="url"
          class=""
          href="https://micahkepe.com/blog/"
        >
          <span itemprop="name">Home</span>
        </a>
        
        <a
          itemprop="url"
          class=""
          href="https://micahkepe.com/blog/categories"
        >
          <span itemprop="name">Categories</span>
        </a>
        
        <a
          itemprop="url"
          class=""
          href="https://micahkepe.com/blog/tags"
        >
          <span itemprop="name">Tags</span>
        </a>
        
        <a
          itemprop="url"
          class=""
          href="https://micahkepe.com/"
        >
          <span itemprop="name">Main Site</span>
        </a>
        
      </section>
    </nav>
    <aside class="user-actions-container">
      
      <svg
        xmlns="http://www.w3.org/2000/svg"
        fill="none"
        viewBox="0 0 24 24"
        stroke-width="1.5"
        class="search-icon"
      >
        <path
          stroke-linecap="round"
          stroke-linejoin="round"
          d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607Z"
        />
      </svg>
      <input type="text" id="search" placeholder="Search..." />
      <section class="search-results" aria-live="polite">
        <article class="search-results__items" role="list"></article>
      </section>
       
      <a id="dark-mode-toggle" href="#">
        <img
          src="https://micahkepe.com/blog/icons/sun.svg"
          id="sun-icon"
          style="filter: invert(1)"
          alt="Light mode"
        />
        <img
          src="https://micahkepe.com/blog/icons/moon.svg"
          id="moon-icon"
          alt="Dark mode"
        />
      </a>
       
      <a
        href="https://micahkepe.com/blog/atom.xml"
        class="feed-icon"
        rel="noopener noreferrer"
      >
        <img
          src="https://micahkepe.com/blog/icons/rss.svg"
          id="rss-icon"
          alt="RSS feed"
          class="social-icon"
        />
      </a>
       
      <a
        href="https:&#x2F;&#x2F;github.com&#x2F;micahkepe"
        class="feed-icon"
        rel="noopener noreferrer"
      >
        <img
          src="https://micahkepe.com/blog/icons/github.svg"
          id="github-icon"
          alt="GitHub"
          class="social-icon"
        />
      </a>
       
    </aside>
  </section>
  

    


    <main>
      

<article itemscope itemtype="http://schema.org/BlogPosting">
    <header>
        <h1 itemprop="headline">Let&#x27;s Build a (Mini)Shell in Rust</h1>
        <data class="muted">
    <svg class="icon i-clock" viewBox="0 0 32 32"
         width="16" height="16" fill="none" stroke="currentcolor"
         stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
        <circle cx="16" cy="16" r="14"/>
        <path d="M16 8 L16 16 20 20"/>
    </svg>
    <data>17 minute read</data>
    <svg class="icon i-edit" viewBox="0 0 32 32"
         width="16" height="16" fill="none" stroke="currentcolor"
         stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
        <path d="M30 7 L25 2 5 22 3 29 10 27 Z M21 6 L26 11 Z M5 22 L10 27 Z"/>
    </svg>

    Published: 2025-05-31
</data>
    </header>

    <article itemprop="articleBody">
        
            <p>In a little over 100 lines of Rust code, we can build a simple shell program
that can execute commands, supports piping, handles signals, and maintains
command history. This tutorial will guide you through the process of creating
a minimal shell, which we will call "minishell", using Rust's powerful standard
library and some external crates.</p>

            
              <details class="toc-container">
  <summary class="toc-title">Table of Contents</summary>
  <ul class="toc-list">
    
    <li>
      <a href="https://micahkepe.com/blog/minishell/#what-is-a-shell">What is a Shell?</a>
      
    </li>
    
    <li>
      <a href="https://micahkepe.com/blog/minishell/#prompting-for-input">Prompting for Input</a>
      
    </li>
    
    <li>
      <a href="https://micahkepe.com/blog/minishell/#parsing-input">Parsing Input</a>
      
    </li>
    
    <li>
      <a href="https://micahkepe.com/blog/minishell/#executing-commands">Executing Commands</a>
      
      <ul>
        
        <li>
          <a href="https://micahkepe.com/blog/minishell/#how-shells-create-process">How Shells Create Process</a>
        </li>
         
        <li>
          <a href="https://micahkepe.com/blog/minishell/#built-in-commands">Built-in Commands</a>
        </li>
        
        <ul>
          
          <li>
            <a href="https://micahkepe.com/blog/minishell/#implementing-cd-and-exit-built-in-commands">Implementing cd and exit Built-in Commands</a>
          </li>
          
        </ul>
         
      </ul>
      
    </li>
    
    <li>
      <a href="https://micahkepe.com/blog/minishell/#executing-external-commands">Executing External Commands</a>
      
      <ul>
        
        <li>
          <a href="https://micahkepe.com/blog/minishell/#piping-commands">Piping Commands</a>
        </li>
         
      </ul>
      
    </li>
    
    <li>
      <a href="https://micahkepe.com/blog/minishell/#extending-our-shell-with-rustyline">Extending Our Shell with rustyline</a>
      
      <ul>
        
        <li>
          <a href="https://micahkepe.com/blog/minishell/#command-history">Command History</a>
        </li>
         
        <li>
          <a href="https://micahkepe.com/blog/minishell/#signal-handling">Signal Handling</a>
        </li>
         
      </ul>
      
    </li>
    
    <li>
      <a href="https://micahkepe.com/blog/minishell/#bonus-greeting-message">Bonus: Greeting Message</a>
      
    </li>
    
    <li>
      <a href="https://micahkepe.com/blog/minishell/#the-complete-script">The Complete Script</a>
      
    </li>
    
    <li>
      <a href="https://micahkepe.com/blog/minishell/#final-word">Final Word</a>
      
    </li>
    
    <li>
      <a href="https://micahkepe.com/blog/minishell/#footnotes">Footnotes</a>
      
    </li>
    
  </ul>
</details>

            

            <!-- Render the rest of the content after removing the summary portion -->
            
<span id="continue-reading"></span><h2 id="what-is-a-shell"><a class="zola-anchor" href="#what-is-a-shell" aria-label="Anchor link for: what-is-a-shell">What is a Shell?</a></h2>
<p>No doubt you've used a shell before, whether it be the Windows Command Prompt,
PowerShell, or a Unix shell like Bash or Zsh. A shell is a command-line
interface that lets users interact with their operating system, whether it be
file management, starting processes, or something else. The "shell" in a shell
program refers to the fact that the shell is a wrapper around the operating
system's functionality via the kernel's APIs.</p>
<p>At its core, the lifecycle of a shell can be summarized as follows<sup class="footnote-reference"><a href="#1">1</a></sup>:</p>
<ol>
<li><strong>Read</strong>: The shell reads a command from the user.</li>
<li><strong>Parse</strong>: It parses the command to understand what needs to be done.</li>
<li><strong>Execute</strong>: The shell executes the command, which may involve running a
program, executing a script, or performing some other action.</li>
<li><strong>Output</strong>: The shell displays the output of the command to the user.</li>
</ol>
<p>Recognizing this, we can see that if we want to build a shell, we need a way
to continuously prompt the user for input, parse that input, and then hand
off the parsed commands to the operating system to execute. With this
as our starting point, we can begin building our shell.</p>
<p>Let's first start by creating a new Rust project for our shell:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#6c7079;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#eb6772;">cargo</span><span style="color:#abb2bf;"> new minishell
</span></code></pre>
<p>Next, navigate to the <code>main.rs</code> file in the <code>src</code> directory and open it in your
text editor of choice.</p>
<h2 id="prompting-for-input"><a class="zola-anchor" href="#prompting-for-input" aria-label="Anchor link for: prompting-for-input">Prompting for Input</a></h2>
<p>Since our shell will be a command-line interface, we need to prompt the user
for input and read that input. In Unix-like systems, this is typically done
from the "stdin" (standard input) stream. In Rust, we can make use the <code>std::io</code>
module to read input from the user. Let's start with just a basic loop:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#6c7079;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5f697a;">// src/main.rs
</span><span style="color:#abb2bf;">
</span><span style="color:#cd74e8;">use </span><span style="color:#abb2bf;">std::io::{</span><span style="color:#eb6772;">self</span><span style="color:#abb2bf;">, Write};
</span><span style="color:#abb2bf;">
</span><span style="color:#cd74e8;">fn </span><span style="color:#5cb3fa;">main</span><span style="color:#abb2bf;">() {
</span><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">loop </span><span style="color:#abb2bf;">{
</span><span style="color:#abb2bf;">        </span><span style="font-style:italic;color:#5f697a;">// Print the prompt
</span><span style="color:#abb2bf;">        print!(</span><span style="color:#9acc76;">&quot;&gt; &quot;</span><span style="color:#abb2bf;">);
</span><span style="color:#abb2bf;">
</span><span style="color:#abb2bf;">        </span><span style="font-style:italic;color:#5f697a;">// Ensure prompt is displayed immediately
</span><span style="color:#abb2bf;">        io::stdout().</span><span style="color:#5ebfcc;">flush</span><span style="color:#abb2bf;">().</span><span style="color:#5ebfcc;">unwrap</span><span style="color:#abb2bf;">();
</span><span style="color:#abb2bf;">
</span><span style="color:#abb2bf;">        </span><span style="font-style:italic;color:#5f697a;">// Read user input
</span><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> input </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">String::new();
</span><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">match </span><span style="color:#abb2bf;">io::stdin().</span><span style="color:#5ebfcc;">read_line</span><span style="color:#abb2bf;">(</span><span style="color:#adb7c9;">&amp;</span><span style="color:#cd74e8;">mut</span><span style="color:#abb2bf;"> input) {
</span><span style="color:#abb2bf;">            Ok(</span><span style="color:#adb7c9;">_</span><span style="color:#abb2bf;">) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> input </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> input.</span><span style="color:#5ebfcc;">trim</span><span style="color:#abb2bf;">();
</span><span style="color:#abb2bf;">
</span><span style="color:#abb2bf;">                </span><span style="font-style:italic;color:#5f697a;">// For now, just echo the input
</span><span style="color:#abb2bf;">                println!(</span><span style="color:#9acc76;">&quot;You entered: </span><span style="color:#db9d63;">{}</span><span style="color:#9acc76;">&quot;</span><span style="color:#abb2bf;">, input);
</span><span style="color:#abb2bf;">            }
</span><span style="color:#abb2bf;">            Err(error) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span><span style="color:#abb2bf;">                eprintln!(</span><span style="color:#9acc76;">&quot;Error reading input: </span><span style="color:#db9d63;">{}</span><span style="color:#9acc76;">&quot;</span><span style="color:#abb2bf;">, error);
</span><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">break</span><span style="color:#abb2bf;">;
</span><span style="color:#abb2bf;">            }
</span><span style="color:#abb2bf;">        }
</span><span style="color:#abb2bf;">    }
</span><span style="color:#abb2bf;">}
</span></code></pre>
<p>There are several important things to note here:</p>
<ul>
<li>We use <code>print!</code> instead of <code>println!</code> to avoid a newline after the prompt.</li>
<li>We call <code>io::stdout().flush()</code> to ensure the prompt is displayed immediately
before reading input. Without this, the default buffering behavior may
delay the prompt until after the user has entered input, which is not
what we want.</li>
<li>We read a line of input from the user using <code>io::stdin().read_line()</code>. This
returns a <code>Result</code> that either contains the number of bytes read (which
we ignore here) or an error.</li>
</ul>
<p>To run this code, you can use the <code>cargo run</code> command in your terminal:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#6c7079;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#5ebfcc;">cd</span><span style="color:#abb2bf;"> minishell
</span><span style="color:#eb6772;">cargo</span><span style="color:#abb2bf;"> run
</span></code></pre>
<h2 id="parsing-input"><a class="zola-anchor" href="#parsing-input" aria-label="Anchor link for: parsing-input">Parsing Input</a></h2>
<p>Alright, so now we can take input from the user, but we need to parse that input
into commands that we can execute.</p>
<p>For our basic naive shell, we'll split the input into words separated by
whitespace (don't worry, we'll improve this later), where the first word is the
command and the remaining words are arguments. Let's update our code to handle
this:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#6c7079;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5f697a;">// src/main.rs
</span><span style="color:#abb2bf;">
</span><span style="color:#cd74e8;">use </span><span style="color:#abb2bf;">std::io::{</span><span style="color:#eb6772;">self</span><span style="color:#abb2bf;">, Write};
</span><span style="color:#abb2bf;">
</span><span style="color:#cd74e8;">fn </span><span style="color:#5cb3fa;">main</span><span style="color:#abb2bf;">() {
</span><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">loop </span><span style="color:#abb2bf;">{
</span><span style="color:#abb2bf;">        print!(</span><span style="color:#9acc76;">&quot;&gt; &quot;</span><span style="color:#abb2bf;">);
</span><span style="color:#abb2bf;">        io::stdout().</span><span style="color:#5ebfcc;">flush</span><span style="color:#abb2bf;">().</span><span style="color:#5ebfcc;">unwrap</span><span style="color:#abb2bf;">();
</span><span style="color:#abb2bf;">
</span><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> input </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">String::new();
</span><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">match </span><span style="color:#abb2bf;">io::stdin().</span><span style="color:#5ebfcc;">read_line</span><span style="color:#abb2bf;">(</span><span style="color:#adb7c9;">&amp;</span><span style="color:#cd74e8;">mut</span><span style="color:#abb2bf;"> input) {
</span><span style="color:#abb2bf;">            Ok(</span><span style="color:#adb7c9;">_</span><span style="color:#abb2bf;">) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> input </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> input.</span><span style="color:#5ebfcc;">trim</span><span style="color:#abb2bf;">();
</span><span style="color:#abb2bf;">
</span><span style="color:#abb2bf;">                </span><span style="font-style:italic;color:#5f697a;">// skip empty input
</span><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">if</span><span style="color:#abb2bf;"> input.</span><span style="color:#5ebfcc;">is_empty</span><span style="color:#abb2bf;">() {
</span><span style="color:#abb2bf;">                    </span><span style="color:#cd74e8;">continue</span><span style="color:#abb2bf;">;
</span><span style="color:#abb2bf;">                }
</span><span style="color:#abb2bf;">
</span><span style="color:#abb2bf;">                </span><span style="font-style:italic;color:#5f697a;">// Parse the input into command and arguments
</span><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> parts </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> input.</span><span style="color:#5ebfcc;">split_whitespace</span><span style="color:#abb2bf;">();
</span><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> command </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> parts.</span><span style="color:#5ebfcc;">next</span><span style="color:#abb2bf;">().</span><span style="color:#5ebfcc;">unwrap</span><span style="color:#abb2bf;">();
</span><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> args: Vec&lt;</span><span style="color:#adb7c9;">&amp;</span><span style="color:#cd74e8;">str</span><span style="color:#abb2bf;">&gt; </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> parts.</span><span style="color:#5ebfcc;">collect</span><span style="color:#abb2bf;">();
</span><span style="color:#abb2bf;">
</span><span style="color:#abb2bf;">                println!(</span><span style="color:#9acc76;">&quot;Command: </span><span style="color:#db9d63;">{}</span><span style="color:#9acc76;">&quot;</span><span style="color:#abb2bf;">, command);
</span><span style="color:#abb2bf;">                println!(</span><span style="color:#9acc76;">&quot;Arguments: </span><span style="color:#db9d63;">{:?}</span><span style="color:#9acc76;">&quot;</span><span style="color:#abb2bf;">, args);
</span><span style="color:#abb2bf;">            }
</span><span style="color:#abb2bf;">            Err(error) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span><span style="color:#abb2bf;">                eprintln!(</span><span style="color:#9acc76;">&quot;Error reading input: </span><span style="color:#db9d63;">{}</span><span style="color:#9acc76;">&quot;</span><span style="color:#abb2bf;">, error);
</span><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">break</span><span style="color:#abb2bf;">;
</span><span style="color:#abb2bf;">            }
</span><span style="color:#abb2bf;">        }
</span><span style="color:#abb2bf;">    }
</span><span style="color:#abb2bf;">}
</span></code></pre>
<p>Now when we enter a command like <code>ls -la</code>, the shell will parse it into:</p>
<pre data-lang="text" style="background-color:#2b303b;color:#6c7079;" class="language-text "><code class="language-text" data-lang="text"><span style="color:#abb2bf;">Command: ls
</span><span style="color:#abb2bf;">Arguments: [&quot;-la&quot;]
</span></code></pre>
<p>Obviously, this is very basic parsing, and it doesn't handle multiple commands
and/or piping, but we will fix that later. For now, we have a basic shell that
can read input from the user and parse that input into a command and its
arguments.</p>
<h2 id="executing-commands"><a class="zola-anchor" href="#executing-commands" aria-label="Anchor link for: executing-commands">Executing Commands</a></h2>
<p>We now have a basic shell that can read input from the user and parse that
input into a sequence of commands that can be executed by spawning new
processes. However, not all commands are equally handled by the shell, leading
to the need for built-in commands and understanding how shells create processes.</p>
<h3 id="how-shells-create-process"><a class="zola-anchor" href="#how-shells-create-process" aria-label="Anchor link for: how-shells-create-process">How Shells Create Process</a></h3>
<p>Before we execute commands, I think a little background on how shells create
processes is in order. When a shell executes a command, it typically does so
by creating a new process, a process being an instance of a running program.</p>
<p>In Unix-like systems, this is done using the <code>fork</code> and <code>exec</code> system calls:</p>
<ol>
<li><strong>Fork</strong>: The shell creates a new process by duplicating itself using the
<a href="https://man7.org/linux/man-pages/man2/fork.2.html"><code>fork</code></a> system call.
This creates a child process that is an <strong>exact copy</strong> of the parent shell
process (this will become important later).</li>
<li><strong>Exec</strong>: The shell then replaces the child process's memory space with the
new command using the
<a href="https://man7.org/linux/man-pages/man3/exec.3.html"><code>exec</code></a> system call.
This means that the child process is now running the new command, but it
still has the same process ID (PID) as the original shell.</li>
</ol>
<p>As a result, the child process can run independently of the parent shell,
and the shell can continue to run and accept new commands. When the child
process finishes executing the command, it can return an exit status to the
parent shell, which can then display the result to the user.</p>
<blockquote>
<p>Even though these details are abstracted away in Rust, they are still
important to understand how our shell will work. When we execute a command,
we will use the <code>Command</code> struct from the <code>std::process</code> module, which
internally handles the <code>fork</code> and <code>exec</code> system calls for us. The <code>Command</code>
struct provides a convenient way to spawn new processes and pass arguments to
them.</p>
</blockquote>
<h3 id="built-in-commands"><a class="zola-anchor" href="#built-in-commands" aria-label="Anchor link for: built-in-commands">Built-in Commands</a></h3>
<p>With this in mind, the method of creating processes necessitates why shells
have built-in commands like <code>cd</code> (change directory) or <code>exit</code>. These commands
<strong>must</strong> be handled by the shell itself rather than being passed to the
operating system.</p>
<p>Why? Take for example the case of <code>cd</code>. Remember that when we <code>fork</code> a new
process, it is a <strong>copy</strong> of the parent shell. If we were to <code>exec</code> a command
like <code>cd</code>, it would change the directory of the child process, but once that
child process exits, the parent shell's working directory would remain
unchanged. Thus, the shell must handle <code>cd</code> itself to change its own working
directory. In a similar vein, the <code>exit</code> command must also be handled by the
shell as it needs to terminate the shell process itself, not just a child
process.</p>
<pre data-lang="text" style="background-color:#2b303b;color:#6c7079;" class="language-text "><code class="language-text" data-lang="text"><span style="color:#abb2bf;">Shell Process (Working Directory: /home/user)
</span><span style="color:#abb2bf;">    |
</span><span style="color:#abb2bf;">    └── Child Process: `cd /tmp` (Working Directory: /tmp)
</span><span style="color:#abb2bf;">        [Process exits, directory change is lost]
</span><span style="color:#abb2bf;">    |
</span><span style="color:#abb2bf;">Shell Process (Working Directory: still /home/user!)
</span></code></pre>
<h4 id="implementing-cd-and-exit-built-in-commands"><a class="zola-anchor" href="#implementing-cd-and-exit-built-in-commands" aria-label="Anchor link for: implementing-cd-and-exit-built-in-commands">Implementing <code>cd</code> and <code>exit</code> Built-in Commands</a></h4>
<p>Let's implement the <code>cd</code> and <code>exit</code> built-in commands in our shell. We'll
add a match arm to handle these commands before we attempt to execute any
external commands. Here's how we can do that:</p>
<pre data-linenos data-lang="rust" style="background-color:#2b303b;color:#6c7079;" class="language-rust "><code class="language-rust" data-lang="rust"><table><tbody><tr><td>1</td><td><span style="color:#cd74e8;">use </span><span style="color:#abb2bf;">std::{
</span></td></tr><tr><td>2</td><td><span style="color:#abb2bf;">    env,
</span></td></tr><tr><td>3</td><td><span style="color:#abb2bf;">    error::Error,
</span></td></tr><tr><td>4</td><td><span style="color:#abb2bf;">    io::{stdin, stdout, Write},
</span></td></tr><tr><td>5</td><td><span style="color:#abb2bf;">    path::Path,
</span></td></tr><tr><td>6</td><td><span style="color:#abb2bf;">};
</span></td></tr><tr><td>7</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>8</td><td><span style="color:#cd74e8;">fn </span><span style="color:#5cb3fa;">main</span><span style="color:#abb2bf;">() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span></td></tr><tr><td>9</td><td><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">loop </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>10</td><td><span style="color:#abb2bf;">        print!(</span><span style="color:#9acc76;">&quot;&gt; &quot;</span><span style="color:#abb2bf;">);
</span></td></tr><tr><td>11</td><td><span style="color:#abb2bf;">        </span><span style="color:#5ebfcc;">stdout</span><span style="color:#abb2bf;">().</span><span style="color:#5ebfcc;">flush</span><span style="color:#abb2bf;">()</span><span style="color:#adb7c9;">?</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>12</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>13</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> input </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">String::new();
</span></td></tr><tr><td>14</td><td><span style="color:#abb2bf;">        </span><span style="color:#5ebfcc;">stdin</span><span style="color:#abb2bf;">().</span><span style="color:#5ebfcc;">read_line</span><span style="color:#abb2bf;">(</span><span style="color:#adb7c9;">&amp;</span><span style="color:#cd74e8;">mut</span><span style="color:#abb2bf;"> input)</span><span style="color:#adb7c9;">?</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>15</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> input </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> input.</span><span style="color:#5ebfcc;">trim</span><span style="color:#abb2bf;">();
</span></td></tr><tr><td>16</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>17</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">if</span><span style="color:#abb2bf;"> input.</span><span style="color:#5ebfcc;">is_empty</span><span style="color:#abb2bf;">() {
</span></td></tr><tr><td>18</td><td><span style="color:#abb2bf;">            </span><span style="color:#cd74e8;">continue</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>19</td><td><span style="color:#abb2bf;">        }
</span></td></tr><tr><td>20</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>21</td><td><span style="color:#abb2bf;">        </span><span style="font-style:italic;color:#5f697a;">// Parse the input into command and arguments
</span></td></tr><tr><td>22</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> parts </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> input.</span><span style="color:#5ebfcc;">split_whitespace</span><span style="color:#abb2bf;">();
</span></td></tr><tr><td>23</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">let </span><span style="color:#abb2bf;">Some(command) </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> parts.</span><span style="color:#5ebfcc;">next</span><span style="color:#abb2bf;">() </span><span style="color:#cd74e8;">else </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>24</td><td><span style="color:#abb2bf;">            </span><span style="color:#cd74e8;">continue</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>25</td><td><span style="color:#abb2bf;">        };
</span></td></tr><tr><td>26</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> args: Vec&lt;</span><span style="color:#adb7c9;">&amp;</span><span style="color:#cd74e8;">str</span><span style="color:#abb2bf;">&gt; </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> parts.</span><span style="color:#5ebfcc;">collect</span><span style="color:#abb2bf;">();
</span></td></tr><tr><td>27</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>28</td><td><span style="color:#abb2bf;">        </span><span style="font-style:italic;color:#5f697a;">// Handle built-in commands first
</span></td></tr><tr><td>29</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">match</span><span style="color:#abb2bf;"> command {
</span></td></tr><tr><td>30</td><td><span style="color:#abb2bf;">            </span><span style="color:#9acc76;">&quot;cd&quot; </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>31</td><td><span style="color:#abb2bf;">                </span><span style="font-style:italic;color:#5f697a;">// Handle cd command - must be done by shell itself
</span></td></tr><tr><td>32</td><td><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> new_dir </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> args.</span><span style="color:#5ebfcc;">first</span><span style="color:#abb2bf;">().</span><span style="color:#5ebfcc;">unwrap_or</span><span style="color:#abb2bf;">(</span><span style="color:#adb7c9;">&amp;</span><span style="color:#9acc76;">&quot;/&quot;</span><span style="color:#abb2bf;">);
</span></td></tr><tr><td>33</td><td><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> root </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">Path::new(new_dir);
</span></td></tr><tr><td>34</td><td><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">if let </span><span style="color:#abb2bf;">Err(e) </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">env::set_current_dir(root) {
</span></td></tr><tr><td>35</td><td><span style="color:#abb2bf;">                    eprintln!(</span><span style="color:#9acc76;">&quot;cd: </span><span style="color:#db9d63;">{}</span><span style="color:#9acc76;">&quot;</span><span style="color:#abb2bf;">, e);
</span></td></tr><tr><td>36</td><td><span style="color:#abb2bf;">                }
</span></td></tr><tr><td>37</td><td><span style="color:#abb2bf;">            }
</span></td></tr><tr><td>38</td><td><span style="color:#abb2bf;">            </span><span style="color:#9acc76;">&quot;exit&quot; </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>39</td><td><span style="color:#abb2bf;">                </span><span style="font-style:italic;color:#5f697a;">// Handle exit command - terminate the shell
</span></td></tr><tr><td>40</td><td><span style="color:#abb2bf;">                println!(</span><span style="color:#9acc76;">&quot;Goodbye!&quot;</span><span style="color:#abb2bf;">);
</span></td></tr><tr><td>41</td><td><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">return </span><span style="color:#abb2bf;">Ok(());
</span></td></tr><tr><td>42</td><td><span style="color:#abb2bf;">            }
</span></td></tr><tr><td>43</td><td><span style="color:#abb2bf;">            </span><span style="font-style:italic;color:#5f697a;">// All other commands are external commands
</span></td></tr><tr><td>44</td><td><span style="color:#abb2bf;">            command </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>45</td><td><span style="color:#abb2bf;">                println!(
</span></td></tr><tr><td>46</td><td><span style="color:#abb2bf;">                    </span><span style="color:#9acc76;">&quot;Executing external command: </span><span style="color:#db9d63;">{}</span><span style="color:#9acc76;"> with args: </span><span style="color:#db9d63;">{:?}</span><span style="color:#9acc76;">&quot;</span><span style="color:#abb2bf;">,
</span></td></tr><tr><td>47</td><td><span style="color:#abb2bf;">                    command, args
</span></td></tr><tr><td>48</td><td><span style="color:#abb2bf;">                );
</span></td></tr><tr><td>49</td><td><span style="color:#abb2bf;">                </span><span style="font-style:italic;color:#5f697a;">// We&#39;ll implement this in the next step
</span></td></tr><tr><td>50</td><td><span style="color:#abb2bf;">            }
</span></td></tr><tr><td>51</td><td><span style="color:#abb2bf;">        }
</span></td></tr><tr><td>52</td><td><span style="color:#abb2bf;">    }
</span></td></tr><tr><td>53</td><td><span style="color:#abb2bf;">}
</span></td></tr><tr><td>54</td><td><span style="color:#abb2bf;">
</span></td></tr></tbody></table></code></pre>
<article class="note-container">
  <details open class="note-details">
    <summary class="note-header">
      
      <section class="note-icon">
        <p>Note</p>

      </section>
      
    </summary>
    <section class="note-content">
      <p>The revised <code>main</code> function signature now returns a <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>, which allows us to handle errors more gracefully with <code>?</code> instead of
panicking.</p>

    </section>
  </details>
</article>
<p>In this new version, we do the same whitespace splitting as before to get
the command and its arguments. Next, in the match expression, we check
if the command is <code>cd</code> or <code>exit</code>.</p>
<p>Looking a little closer at the <code>cd</code> command, we use the <code>env::set_current_dir</code>
function to change the current working directory of the shell process. If the
directory change fails (for example, if the directory does not exist), we
print an error message to the user. The <code>unwrap_or(&amp;"/")</code> ensures that if no
argument is provided, we default to the root directory <code>/</code>.</p>
<blockquote>
<p>You might be asking when not use <code>~</code> as the default directory? The reason is
that <code>~</code> is a shell-specific shorthand for the user's home directory, and it
is not universally recognized by all shells. Using <code>/</code> as the default ensures
that our shell behaves consistently across different environments, as <code>/</code> is
the root directory in Unix-like systems. If you want to support <code>~</code>, you
would need to expand it to the user's home directory using <code>dirs::home_dir()</code>
from the <a href="https://crates.io/crates/dirs"><code>dirs</code> crate</a>. This is left as a
future exercise for the reader.</p>
</blockquote>
<p>In our implementation we just support the <code>cd</code> and <code>exit</code> built-in commands,
but for a complete, POSIX-compliant shell, there are many more built-in
commands that would need to be implemented, such as <code>export</code>, <code>alias</code>, and
<code>source</code>. For a complete list, see section <a href="https://pubs.opengroup.org/onlinepubs/9699919799.2018edition/">1.6 Built-In Utilities</a>
in the latest POSIX standard.</p>
<h2 id="executing-external-commands"><a class="zola-anchor" href="#executing-external-commands" aria-label="Anchor link for: executing-external-commands">Executing External Commands</a></h2>
<p>Now that we have the built-in commands handled, we can implement the logic to
execute external commands. We'll use the <code>Command</code> struct from the <code>std::process</code>
module to spawn new processes. The <code>Command</code> struct provides a convenient way
to create and configure a new process, including setting the command to run,
passing arguments, and handling input/output streams.</p>
<p>To execute an external command, we can use the <code>Command::new</code> method to
create a new command, and then we can call the <code>spawn</code> method to run the command
in a new process. For example, to run the <code>ls -la</code> command, we can do the
following:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#6c7079;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#cd74e8;">use </span><span style="color:#abb2bf;">std::process::Command;
</span><span style="color:#abb2bf;">
</span><span style="font-style:italic;color:#5f697a;">// use Builder pattern to create a new command
</span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> output </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">Command::new(</span><span style="color:#9acc76;">&quot;ls&quot;</span><span style="color:#abb2bf;">) </span><span style="font-style:italic;color:#5f697a;">// create a new command
</span><span style="color:#abb2bf;">    .</span><span style="color:#5ebfcc;">arg</span><span style="color:#abb2bf;">(</span><span style="color:#9acc76;">&quot;-la&quot;</span><span style="color:#abb2bf;">) </span><span style="font-style:italic;color:#5f697a;">// add argument(s)
</span><span style="color:#abb2bf;">    .</span><span style="color:#5ebfcc;">output</span><span style="color:#abb2bf;">() </span><span style="font-style:italic;color:#5f697a;">// execute the command and capture output
</span><span style="color:#abb2bf;">    .</span><span style="color:#5ebfcc;">expect</span><span style="color:#abb2bf;">(</span><span style="color:#9acc76;">&quot;Failed to execute command&quot;</span><span style="color:#abb2bf;">); </span><span style="font-style:italic;color:#5f697a;">// handle any errors
</span></code></pre>
<p>This will run the <code>ls -la</code> command and capture its output. The <code>output</code> method
returns a <code>Result&lt;Output&gt;</code>, where <code>Output</code> contains the standard output and
standard error of the command. We can then print the output to the user.</p>
<p>For our shell, we'll primarily use <code>spawn()</code> because we want to control when to
wait for the process to complete.</p>
<p>Let's integrate this into our shell, so that it can execute external commands:</p>
<pre data-linenos data-lang="rust" style="background-color:#2b303b;color:#6c7079;" class="language-rust "><code class="language-rust" data-lang="rust"><table><tbody><tr><td>1</td><td><span style="color:#cd74e8;">use </span><span style="color:#abb2bf;">std::{
</span></td></tr><tr><td>2</td><td><span style="color:#abb2bf;">    env,
</span></td></tr><tr><td>3</td><td><span style="color:#abb2bf;">    error::Error,
</span></td></tr><tr><td>4</td><td><span style="color:#abb2bf;">    io::{stdin, stdout, Write},
</span></td></tr><tr><td>5</td><td><span style="color:#abb2bf;">    path::Path,
</span></td></tr><tr><td>6</td><td><span style="color:#abb2bf;">    process::Command,
</span></td></tr><tr><td>7</td><td><span style="color:#abb2bf;">};
</span></td></tr><tr><td>8</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>9</td><td><span style="color:#cd74e8;">fn </span><span style="color:#5cb3fa;">main</span><span style="color:#abb2bf;">() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span></td></tr><tr><td>10</td><td><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">loop </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>11</td><td><span style="color:#abb2bf;">        print!(</span><span style="color:#9acc76;">&quot;&gt; &quot;</span><span style="color:#abb2bf;">);
</span></td></tr><tr><td>12</td><td><span style="color:#abb2bf;">        </span><span style="color:#5ebfcc;">stdout</span><span style="color:#abb2bf;">().</span><span style="color:#5ebfcc;">flush</span><span style="color:#abb2bf;">()</span><span style="color:#adb7c9;">?</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>13</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>14</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> input </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">String::new();
</span></td></tr><tr><td>15</td><td><span style="color:#abb2bf;">        </span><span style="color:#5ebfcc;">stdin</span><span style="color:#abb2bf;">().</span><span style="color:#5ebfcc;">read_line</span><span style="color:#abb2bf;">(</span><span style="color:#adb7c9;">&amp;</span><span style="color:#cd74e8;">mut</span><span style="color:#abb2bf;"> input)</span><span style="color:#adb7c9;">?</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>16</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> input </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> input.</span><span style="color:#5ebfcc;">trim</span><span style="color:#abb2bf;">();
</span></td></tr><tr><td>17</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>18</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">if</span><span style="color:#abb2bf;"> input.</span><span style="color:#5ebfcc;">is_empty</span><span style="color:#abb2bf;">() {
</span></td></tr><tr><td>19</td><td><span style="color:#abb2bf;">            </span><span style="color:#cd74e8;">continue</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>20</td><td><span style="color:#abb2bf;">        }
</span></td></tr><tr><td>21</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>22</td><td><span style="color:#abb2bf;">        </span><span style="font-style:italic;color:#5f697a;">// Parse the input into command and arguments
</span></td></tr><tr><td>23</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> parts </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> input.</span><span style="color:#5ebfcc;">split_whitespace</span><span style="color:#abb2bf;">();
</span></td></tr><tr><td>24</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">let </span><span style="color:#abb2bf;">Some(command) </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> parts.</span><span style="color:#5ebfcc;">next</span><span style="color:#abb2bf;">() </span><span style="color:#cd74e8;">else </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>25</td><td><span style="color:#abb2bf;">            </span><span style="color:#cd74e8;">continue</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>26</td><td><span style="color:#abb2bf;">        };
</span></td></tr><tr><td>27</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> args: Vec&lt;</span><span style="color:#adb7c9;">&amp;</span><span style="color:#cd74e8;">str</span><span style="color:#abb2bf;">&gt; </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> parts.</span><span style="color:#5ebfcc;">collect</span><span style="color:#abb2bf;">();
</span></td></tr><tr><td>28</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>29</td><td><span style="color:#abb2bf;">        </span><span style="font-style:italic;color:#5f697a;">// Handle built-in commands first
</span></td></tr><tr><td>30</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">match</span><span style="color:#abb2bf;"> command {
</span></td></tr><tr><td>31</td><td><span style="color:#abb2bf;">            </span><span style="color:#9acc76;">&quot;cd&quot; </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>32</td><td><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> new_dir </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> args.</span><span style="color:#5ebfcc;">first</span><span style="color:#abb2bf;">().</span><span style="color:#5ebfcc;">unwrap_or</span><span style="color:#abb2bf;">(</span><span style="color:#adb7c9;">&amp;</span><span style="color:#9acc76;">&quot;/&quot;</span><span style="color:#abb2bf;">);
</span></td></tr><tr><td>33</td><td><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> root </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">Path::new(new_dir);
</span></td></tr><tr><td>34</td><td><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">if let </span><span style="color:#abb2bf;">Err(e) </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">env::set_current_dir(root) {
</span></td></tr><tr><td>35</td><td><span style="color:#abb2bf;">                    eprintln!(</span><span style="color:#9acc76;">&quot;cd: </span><span style="color:#db9d63;">{}</span><span style="color:#9acc76;">&quot;</span><span style="color:#abb2bf;">, e);
</span></td></tr><tr><td>36</td><td><span style="color:#abb2bf;">                }
</span></td></tr><tr><td>37</td><td><span style="color:#abb2bf;">            }
</span></td></tr><tr><td>38</td><td><span style="color:#abb2bf;">            </span><span style="color:#9acc76;">&quot;exit&quot; </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>39</td><td><span style="color:#abb2bf;">                println!(</span><span style="color:#9acc76;">&quot;Goodbye!&quot;</span><span style="color:#abb2bf;">);
</span></td></tr><tr><td>40</td><td><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">return </span><span style="color:#abb2bf;">Ok(());
</span></td></tr><tr><td>41</td><td><span style="color:#abb2bf;">            }
</span></td></tr><tr><td>42</td><td><span style="color:#abb2bf;">            </span><span style="font-style:italic;color:#5f697a;">// All other commands are external commands
</span></td></tr><tr><td>43</td><td><span style="color:#abb2bf;">            command </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>44</td><td><span style="color:#abb2bf;">                </span><span style="font-style:italic;color:#5f697a;">// Create a Command struct to spawn the external process
</span></td></tr><tr><td>45</td><td><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> cmd </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">Command::new(command);
</span></td></tr><tr><td>46</td><td><span style="color:#abb2bf;">                cmd.</span><span style="color:#5ebfcc;">args</span><span style="color:#abb2bf;">(</span><span style="color:#adb7c9;">&amp;</span><span style="color:#abb2bf;">args);
</span></td></tr><tr><td>47</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>48</td><td><span style="color:#abb2bf;">                </span><span style="font-style:italic;color:#5f697a;">// Spawn the child process and wait for it to complete
</span></td></tr><tr><td>49</td><td><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">match</span><span style="color:#abb2bf;"> cmd.</span><span style="color:#5ebfcc;">spawn</span><span style="color:#abb2bf;">() {
</span></td></tr><tr><td>50</td><td><span style="color:#abb2bf;">                    Ok(</span><span style="color:#cd74e8;">mut</span><span style="color:#abb2bf;"> child) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>51</td><td><span style="color:#abb2bf;">                        </span><span style="font-style:italic;color:#5f697a;">// Wait for the child process to finish
</span></td></tr><tr><td>52</td><td><span style="color:#abb2bf;">                        </span><span style="color:#cd74e8;">match</span><span style="color:#abb2bf;"> child.</span><span style="color:#5ebfcc;">wait</span><span style="color:#abb2bf;">() {
</span></td></tr><tr><td>53</td><td><span style="color:#abb2bf;">                            Ok(status) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>54</td><td><span style="color:#abb2bf;">                                </span><span style="color:#cd74e8;">if </span><span style="color:#adb7c9;">!</span><span style="color:#abb2bf;">status.</span><span style="color:#5ebfcc;">success</span><span style="color:#abb2bf;">() {
</span></td></tr><tr><td>55</td><td><span style="color:#abb2bf;">                                    eprintln!(</span><span style="color:#9acc76;">&quot;Command &#39;</span><span style="color:#db9d63;">{}</span><span style="color:#9acc76;">&#39; failed with exit code: </span><span style="color:#db9d63;">{:?}</span><span style="color:#9acc76;">&quot;</span><span style="color:#abb2bf;">,
</span></td></tr><tr><td>56</td><td><span style="color:#abb2bf;">                                            command, status.</span><span style="color:#5ebfcc;">code</span><span style="color:#abb2bf;">());
</span></td></tr><tr><td>57</td><td><span style="color:#abb2bf;">                                }
</span></td></tr><tr><td>58</td><td><span style="color:#abb2bf;">                            }
</span></td></tr><tr><td>59</td><td><span style="color:#abb2bf;">                            Err(e) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>60</td><td><span style="color:#abb2bf;">                                eprintln!(</span><span style="color:#9acc76;">&quot;Failed to wait for command &#39;</span><span style="color:#db9d63;">{}</span><span style="color:#9acc76;">&#39;: </span><span style="color:#db9d63;">{}</span><span style="color:#9acc76;">&quot;</span><span style="color:#abb2bf;">, command, e);
</span></td></tr><tr><td>61</td><td><span style="color:#abb2bf;">                            }
</span></td></tr><tr><td>62</td><td><span style="color:#abb2bf;">                        }
</span></td></tr><tr><td>63</td><td><span style="color:#abb2bf;">                    }
</span></td></tr><tr><td>64</td><td><span style="color:#abb2bf;">                    Err(e) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>65</td><td><span style="color:#abb2bf;">                        eprintln!(</span><span style="color:#9acc76;">&quot;Failed to execute command &#39;</span><span style="color:#db9d63;">{}</span><span style="color:#9acc76;">&#39;: </span><span style="color:#db9d63;">{}</span><span style="color:#9acc76;">&quot;</span><span style="color:#abb2bf;">, command, e);
</span></td></tr><tr><td>66</td><td><span style="color:#abb2bf;">                    }
</span></td></tr><tr><td>67</td><td><span style="color:#abb2bf;">                }
</span></td></tr><tr><td>68</td><td><span style="color:#abb2bf;">            }
</span></td></tr><tr><td>69</td><td><span style="color:#abb2bf;">        }
</span></td></tr><tr><td>70</td><td><span style="color:#abb2bf;">    }
</span></td></tr><tr><td>71</td><td><span style="color:#abb2bf;">}
</span></td></tr></tbody></table></code></pre>
<p>Now for any external command:</p>
<ol>
<li>We create a <code>Command</code> instance using <code>Command::new(command)</code>, passing the
command name as an argument.</li>
<li>We then add any additional arguments using <code>cmd.args(&amp;args)</code>.</li>
<li>Call <code>cmd.spawn()</code> to execute the command in a new process.</li>
</ol>
<p>The <code>spawn</code> method returns a <code>Result&lt;Child&gt;</code>, where <code>Child</code> represents the spawned process. We
then wait for the child process to finish using <code>child.wait()</code>, which returns
a <code>Result&lt;ExitStatus&gt;</code>. If the command fails to execute, we print an error
message to the user. If the command succeeds, then it will output its
results to the terminal via the standard output stream.</p>
<h3 id="piping-commands"><a class="zola-anchor" href="#piping-commands" aria-label="Anchor link for: piping-commands">Piping Commands</a></h3>
<p>One of the most powerful features of Unix shells is the ability to pipe the
output of one command as input to another command. The pipe operator <code>|</code> allows
you to chain commands together. For example, <code>ls | grep txt</code> would list files
and then filter for those containing "txt". A major limitation of our current
shell is that is only supports a single command at a time, so let's
extend our shell to support piping commands together.</p>
<p>The first thing we'll do is modify our input parsing to split the input on
the pipe character <code>|</code> instead of whitespace. This will allow us to
handle multiple commands in a single input line. We'll also store these
commands in a <strong>peekable</strong> iterator. Why peekable? Because we want to
check if there are more commands to process after the current one, so we can
decide whether to pipe the output to the next command or not.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#6c7079;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5f697a;">// Split input on pipe characters to handle command chaining
</span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> commands </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> input.</span><span style="color:#5ebfcc;">trim</span><span style="color:#abb2bf;">().</span><span style="color:#5ebfcc;">split</span><span style="color:#abb2bf;">(</span><span style="color:#9acc76;">&quot; | &quot;</span><span style="color:#abb2bf;">).</span><span style="color:#5ebfcc;">peekable</span><span style="color:#abb2bf;">();
</span></code></pre>
<p>Since we are now dealing with multiple commands, we need to keep track of
the output of the previous command so that we can pipe it to the next command,
if there is one. Additionally, we want to track all of the child processes that
we spawn so that we can wait for them to finish later.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#6c7079;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> prev_stdout </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">None; </span><span style="font-style:italic;color:#5f697a;">// This will hold the output of the previous command
</span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> children: Vec&lt;Child&gt; </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">Vec::new(); </span><span style="font-style:italic;color:#5f697a;">// This will hold all child processes we spawn
</span></code></pre>
<p>Next, we will loop through each command in the pipeline, parsing it into
the command name and its arguments, and then executing it. If the command is
<code>cd</code> or <code>exit</code>, we handle it as before. For external commands, we will set up
the <code>stdin</code> and <code>stdout</code> streams based on whether there is a previous command
to pipe from or if it is the last command in the pipeline. If there is a
previous command, we will use its output as the input for the current command.</p>
<p>Putting it all together, our updated shell now looks like this:</p>
<pre data-linenos data-lang="rust" style="background-color:#2b303b;color:#6c7079;" class="language-rust "><code class="language-rust" data-lang="rust"><table><tbody><tr><td>1</td><td><span style="color:#cd74e8;">use </span><span style="color:#abb2bf;">std::{
</span></td></tr><tr><td>2</td><td><span style="color:#abb2bf;">    env,
</span></td></tr><tr><td>3</td><td><span style="color:#abb2bf;">    error::Error,
</span></td></tr><tr><td>4</td><td><span style="color:#abb2bf;">    io::{stdin, stdout, Write},
</span></td></tr><tr><td>5</td><td><span style="color:#abb2bf;">    path::Path,
</span></td></tr><tr><td>6</td><td><span style="color:#abb2bf;">    process::{Child, Command, Stdio},
</span></td></tr><tr><td>7</td><td><span style="color:#abb2bf;">};
</span></td></tr><tr><td>8</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>9</td><td><span style="color:#cd74e8;">fn </span><span style="color:#5cb3fa;">main</span><span style="color:#abb2bf;">() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span></td></tr><tr><td>10</td><td><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">loop </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>11</td><td><span style="color:#abb2bf;">        print!(</span><span style="color:#9acc76;">&quot;&gt; &quot;</span><span style="color:#abb2bf;">);
</span></td></tr><tr><td>12</td><td><span style="color:#abb2bf;">        </span><span style="color:#5ebfcc;">stdout</span><span style="color:#abb2bf;">().</span><span style="color:#5ebfcc;">flush</span><span style="color:#abb2bf;">()</span><span style="color:#adb7c9;">?</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>13</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>14</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> input </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">String::new();
</span></td></tr><tr><td>15</td><td><span style="color:#abb2bf;">        </span><span style="color:#5ebfcc;">stdin</span><span style="color:#abb2bf;">().</span><span style="color:#5ebfcc;">read_line</span><span style="color:#abb2bf;">(</span><span style="color:#adb7c9;">&amp;</span><span style="color:#cd74e8;">mut</span><span style="color:#abb2bf;"> input)</span><span style="color:#adb7c9;">?</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>16</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> input </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> input.</span><span style="color:#5ebfcc;">trim</span><span style="color:#abb2bf;">();
</span></td></tr><tr><td>17</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>18</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">if</span><span style="color:#abb2bf;"> input.</span><span style="color:#5ebfcc;">is_empty</span><span style="color:#abb2bf;">() {
</span></td></tr><tr><td>19</td><td><span style="color:#abb2bf;">            </span><span style="color:#cd74e8;">continue</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>20</td><td><span style="color:#abb2bf;">        }
</span></td></tr><tr><td>21</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>22</td><td><span style="color:#abb2bf;">        </span><span style="font-style:italic;color:#5f697a;">// Split input on pipe characters to handle command chaining
</span></td></tr><tr><td>23</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> commands </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> input.</span><span style="color:#5ebfcc;">trim</span><span style="color:#abb2bf;">().</span><span style="color:#5ebfcc;">split</span><span style="color:#abb2bf;">(</span><span style="color:#9acc76;">&quot; | &quot;</span><span style="color:#abb2bf;">).</span><span style="color:#5ebfcc;">peekable</span><span style="color:#abb2bf;">();
</span></td></tr><tr><td>24</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> prev_stdout </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">None;
</span></td></tr><tr><td>25</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> children: Vec&lt;Child&gt; </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">Vec::new();
</span></td></tr><tr><td>26</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>27</td><td><span style="color:#abb2bf;">        </span><span style="font-style:italic;color:#5f697a;">// Process each command in the pipeline
</span></td></tr><tr><td>28</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">while let </span><span style="color:#abb2bf;">Some(command) </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> commands.</span><span style="color:#5ebfcc;">next</span><span style="color:#abb2bf;">() {
</span></td></tr><tr><td>29</td><td><span style="color:#abb2bf;">            </span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> parts </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> command.</span><span style="color:#5ebfcc;">split_whitespace</span><span style="color:#abb2bf;">();
</span></td></tr><tr><td>30</td><td><span style="color:#abb2bf;">            </span><span style="color:#cd74e8;">let </span><span style="color:#abb2bf;">Some(command) </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> parts.</span><span style="color:#5ebfcc;">next</span><span style="color:#abb2bf;">() </span><span style="color:#cd74e8;">else </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>31</td><td><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">continue</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>32</td><td><span style="color:#abb2bf;">            };
</span></td></tr><tr><td>33</td><td><span style="color:#abb2bf;">            </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> args </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> parts;
</span></td></tr><tr><td>34</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>35</td><td><span style="color:#abb2bf;">            </span><span style="color:#cd74e8;">match</span><span style="color:#abb2bf;"> command {
</span></td></tr><tr><td>36</td><td><span style="color:#abb2bf;">                </span><span style="color:#9acc76;">&quot;cd&quot; </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>37</td><td><span style="color:#abb2bf;">                    </span><span style="font-style:italic;color:#5f697a;">// Built-in: change directory
</span></td></tr><tr><td>38</td><td><span style="color:#abb2bf;">                    </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> new_dir </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> args.</span><span style="color:#5ebfcc;">peekable</span><span style="color:#abb2bf;">().</span><span style="color:#5ebfcc;">peek</span><span style="color:#abb2bf;">().</span><span style="color:#5ebfcc;">map_or</span><span style="color:#abb2bf;">(</span><span style="color:#9acc76;">&quot;/&quot;</span><span style="color:#abb2bf;">, |</span><span style="color:#eb6772;">x</span><span style="color:#abb2bf;">| </span><span style="color:#adb7c9;">*</span><span style="color:#abb2bf;">x);
</span></td></tr><tr><td>39</td><td><span style="color:#abb2bf;">                    </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> root </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">Path::new(new_dir);
</span></td></tr><tr><td>40</td><td><span style="color:#abb2bf;">                    </span><span style="color:#cd74e8;">if let </span><span style="color:#abb2bf;">Err(e) </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">env::set_current_dir(root) {
</span></td></tr><tr><td>41</td><td><span style="color:#abb2bf;">                        eprintln!(</span><span style="color:#9acc76;">&quot;cd: </span><span style="color:#db9d63;">{}</span><span style="color:#9acc76;">&quot;</span><span style="color:#abb2bf;">, e);
</span></td></tr><tr><td>42</td><td><span style="color:#abb2bf;">                    }
</span></td></tr><tr><td>43</td><td><span style="color:#abb2bf;">                    </span><span style="font-style:italic;color:#5f697a;">// Reset prev_stdout since cd doesn&#39;t produce output
</span></td></tr><tr><td>44</td><td><span style="color:#abb2bf;">                    prev_stdout </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">None;
</span></td></tr><tr><td>45</td><td><span style="color:#abb2bf;">                }
</span></td></tr><tr><td>46</td><td><span style="color:#abb2bf;">                </span><span style="color:#9acc76;">&quot;exit&quot; </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>47</td><td><span style="color:#abb2bf;">                    println!(</span><span style="color:#9acc76;">&quot;Goodbye!&quot;</span><span style="color:#abb2bf;">);
</span></td></tr><tr><td>48</td><td><span style="color:#abb2bf;">                    </span><span style="color:#cd74e8;">return </span><span style="color:#abb2bf;">Ok(());
</span></td></tr><tr><td>49</td><td><span style="color:#abb2bf;">                }
</span></td></tr><tr><td>50</td><td><span style="color:#abb2bf;">                command </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>51</td><td><span style="color:#abb2bf;">                    </span><span style="font-style:italic;color:#5f697a;">// External command: set up stdin/stdout for piping
</span></td></tr><tr><td>52</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>53</td><td><span style="color:#abb2bf;">                    </span><span style="font-style:italic;color:#5f697a;">// Input: either from previous command&#39;s output or inherit from shell
</span></td></tr><tr><td>54</td><td><span style="color:#abb2bf;">                    </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> stdin </span><span style="color:#adb7c9;">= </span><span style="color:#cd74e8;">match</span><span style="color:#abb2bf;"> prev_stdout.</span><span style="color:#5ebfcc;">take</span><span style="color:#abb2bf;">() {
</span></td></tr><tr><td>55</td><td><span style="color:#abb2bf;">                        Some(output) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">Stdio::from(output),
</span></td></tr><tr><td>56</td><td><span style="color:#abb2bf;">                        None </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">Stdio::inherit(),
</span></td></tr><tr><td>57</td><td><span style="color:#abb2bf;">                    };
</span></td></tr><tr><td>58</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>59</td><td><span style="color:#abb2bf;">                    </span><span style="font-style:italic;color:#5f697a;">// Output: pipe to next command if there is one, otherwise inherit
</span></td></tr><tr><td>60</td><td><span style="color:#abb2bf;">                    </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> stdout </span><span style="color:#adb7c9;">= </span><span style="color:#cd74e8;">if</span><span style="color:#abb2bf;"> commands.</span><span style="color:#5ebfcc;">peek</span><span style="color:#abb2bf;">().</span><span style="color:#5ebfcc;">is_some</span><span style="color:#abb2bf;">() {
</span></td></tr><tr><td>61</td><td><span style="color:#abb2bf;">                        Stdio::piped()  </span><span style="font-style:italic;color:#5f697a;">// More commands follow, so pipe output
</span></td></tr><tr><td>62</td><td><span style="color:#abb2bf;">                    } </span><span style="color:#cd74e8;">else </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>63</td><td><span style="color:#abb2bf;">                        Stdio::inherit()  </span><span style="font-style:italic;color:#5f697a;">// Last command, output to terminal
</span></td></tr><tr><td>64</td><td><span style="color:#abb2bf;">                    };
</span></td></tr><tr><td>65</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>66</td><td><span style="color:#abb2bf;">                    </span><span style="font-style:italic;color:#5f697a;">// Spawn the command with configured stdin/stdout
</span></td></tr><tr><td>67</td><td><span style="color:#abb2bf;">                    </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> child </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">Command::new(command)
</span></td></tr><tr><td>68</td><td><span style="color:#abb2bf;">                        .</span><span style="color:#5ebfcc;">args</span><span style="color:#abb2bf;">(args)
</span></td></tr><tr><td>69</td><td><span style="color:#abb2bf;">                        .</span><span style="color:#5ebfcc;">stdin</span><span style="color:#abb2bf;">(stdin)
</span></td></tr><tr><td>70</td><td><span style="color:#abb2bf;">                        .</span><span style="color:#5ebfcc;">stdout</span><span style="color:#abb2bf;">(stdout)
</span></td></tr><tr><td>71</td><td><span style="color:#abb2bf;">                        .</span><span style="color:#5ebfcc;">spawn</span><span style="color:#abb2bf;">();
</span></td></tr><tr><td>72</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>73</td><td><span style="color:#abb2bf;">                    </span><span style="color:#cd74e8;">match</span><span style="color:#abb2bf;"> child {
</span></td></tr><tr><td>74</td><td><span style="color:#abb2bf;">                        Ok(</span><span style="color:#cd74e8;">mut</span><span style="color:#abb2bf;"> child) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>75</td><td><span style="color:#abb2bf;">                            </span><span style="font-style:italic;color:#5f697a;">// Take ownership of stdout for next command in pipeline
</span></td></tr><tr><td>76</td><td><span style="color:#abb2bf;">                            prev_stdout </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> child.stdout.</span><span style="color:#5ebfcc;">take</span><span style="color:#abb2bf;">();
</span></td></tr><tr><td>77</td><td><span style="color:#abb2bf;">                            children.</span><span style="color:#5ebfcc;">push</span><span style="color:#abb2bf;">(child);
</span></td></tr><tr><td>78</td><td><span style="color:#abb2bf;">                        }
</span></td></tr><tr><td>79</td><td><span style="color:#abb2bf;">                        Err(e) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>80</td><td><span style="color:#abb2bf;">                            eprintln!(</span><span style="color:#9acc76;">&quot;Failed to execute &#39;</span><span style="color:#db9d63;">{}</span><span style="color:#9acc76;">&#39;: </span><span style="color:#db9d63;">{}</span><span style="color:#9acc76;">&quot;</span><span style="color:#abb2bf;">, command, e);
</span></td></tr><tr><td>81</td><td><span style="color:#abb2bf;">                            </span><span style="color:#cd74e8;">break</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>82</td><td><span style="color:#abb2bf;">                        }
</span></td></tr><tr><td>83</td><td><span style="color:#abb2bf;">                    }
</span></td></tr><tr><td>84</td><td><span style="color:#abb2bf;">                }
</span></td></tr><tr><td>85</td><td><span style="color:#abb2bf;">            }
</span></td></tr><tr><td>86</td><td><span style="color:#abb2bf;">        }
</span></td></tr><tr><td>87</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>88</td><td><span style="color:#abb2bf;">        </span><span style="font-style:italic;color:#5f697a;">// Wait for all child processes to complete
</span></td></tr><tr><td>89</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">for mut</span><span style="color:#abb2bf;"> child </span><span style="color:#adb7c9;">in</span><span style="color:#abb2bf;"> children {
</span></td></tr><tr><td>90</td><td><span style="color:#abb2bf;">            </span><span style="color:#cd74e8;">let </span><span style="color:#adb7c9;">_ =</span><span style="color:#abb2bf;"> child.</span><span style="color:#5ebfcc;">wait</span><span style="color:#abb2bf;">();
</span></td></tr><tr><td>91</td><td><span style="color:#abb2bf;">        }
</span></td></tr><tr><td>92</td><td><span style="color:#abb2bf;">    }
</span></td></tr><tr><td>93</td><td><span style="color:#abb2bf;">}
</span></td></tr></tbody></table></code></pre>
<p>Woohoo! Now our shell can handle multiple commands piped together!
When you run the shell and enter a command like <code>ls | wc -l</code>, it
will execute each command in the pipeline, passing the output of one command
as the input to the next command, with the final output displayed in the
terminal.</p>
<section
  style="width: 100%; max-width: 75%; margin: 0 auto; text-align: center;">
  <img src="./images/piping-example.png"  alt="Example of piping commands in a shell" 
    style="max-width: 100%; height: auto; display: inline-block;">
  
  <caption style="margin-top: 0.5em;">
    <p style="font-style: italic;">Example of piping commands in a shell; `ls | wc -l` counts the number
of files in the current directory</p>
  </caption>
  
</section>
<hr />
<h2 id="extending-our-shell-with-rustyline"><a class="zola-anchor" href="#extending-our-shell-with-rustyline" aria-label="Anchor link for: extending-our-shell-with-rustyline">Extending Our Shell with <a href="https://crates.io/crates/rustyline"><code>rustyline</code></a></a></h2>
<p>If you have been following along, you may have noticed that our shell is
not very user-friendly. If you make a mistake while typing a command, you
cannot edit it by moving the cursor back with arrow keys to the mistake and
correcting it. You also cannot easily recall previous commands or search
through your command history.</p>
<p>To address these shortcomings and make our shell more user-friendly, we can use the
<a href="https://crates.io/crates/rustyline"><code>rustyline</code></a> crate to handle input and
command history. This crate provides a line editor that supports features like
command history, auto-completion, and more. A <strong>line editor</strong> is a text
editor that lets users edit a single line of text, in our case, the prompt
where the user types commands.</p>
<p>For us, we'll use a subset of this functionality to provide two features:
<strong>command history</strong> and <strong>signal handling</strong>.</p>
<p>To get started, let's first add <code>rustyline</code> to our project with Cargo:</p>
<pre data-lang="bash" style="background-color:#2b303b;color:#6c7079;" class="language-bash "><code class="language-bash" data-lang="bash"><span style="color:#eb6772;">cargo</span><span style="color:#abb2bf;"> add rustyline
</span></code></pre>
<h3 id="command-history"><a class="zola-anchor" href="#command-history" aria-label="Anchor link for: command-history">Command History</a></h3>
<p>Many shells store command history so that users can easily recall and reuse
previous commands. For example, in Bash, you can use the up and down arrow keys f
or navigating through the command history, and you can use <code>Ctrl+R</code> to search
for previous commands. This is a very useful feature that makes it easier to
reuse commands without having to retype them.</p>
<p>Doing this in <code>rustyline</code> is very straightforward. We can use the <code>DefaultEditor</code>
type from <code>rustyline</code> to create a new line editor instance, and then we can
load and save command history using the <code>load_history</code> and <code>save_history</code>
methods. Let's update our shell to include command history:</p>
<pre data-linenos data-lang="rust" style="background-color:#2b303b;color:#6c7079;" class="language-rust "><code class="language-rust" data-lang="rust"><table><tbody><tr><td>1</td><td><span style="font-style:italic;color:#5f697a;">// src/main.rs
</span></td></tr><tr><td>2</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td><mark style="background-color:#8cc2fc0b;">3</mark></td><td><mark style="background-color:#8cc2fc0b;"><span style="color:#cd74e8;">use </span><span style="color:#abb2bf;">rustyline::error::ReadlineError;
</span></mark></td></tr><tr><td><mark style="background-color:#8cc2fc0b;">4</mark></td><td><mark style="background-color:#8cc2fc0b;"><span style="color:#cd74e8;">use </span><span style="color:#abb2bf;">rustyline::DefaultEditor;
</span></mark></td></tr><tr><td>5</td><td><span style="color:#cd74e8;">use </span><span style="color:#abb2bf;">std::{
</span></td></tr><tr><td>6</td><td><span style="color:#abb2bf;">    env,
</span></td></tr><tr><td>7</td><td><span style="color:#abb2bf;">    error::Error,
</span></td></tr><tr><td>8</td><td><span style="color:#abb2bf;">    fs,
</span></td></tr><tr><td>9</td><td><span style="color:#abb2bf;">    path::Path,
</span></td></tr><tr><td>10</td><td><span style="color:#abb2bf;">    process::{Child, Command, Stdio},
</span></td></tr><tr><td>11</td><td><span style="color:#abb2bf;">};
</span></td></tr><tr><td>12</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>13</td><td><span style="color:#cd74e8;">fn </span><span style="color:#5cb3fa;">main</span><span style="color:#abb2bf;">() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span></td></tr><tr><td>14</td><td><span style="color:#abb2bf;">    </span><span style="font-style:italic;color:#5f697a;">// Create a new line editor instance with default settings
</span></td></tr><tr><td><mark style="background-color:#8cc2fc0b;">15</mark></td><td><mark style="background-color:#8cc2fc0b;"><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> rl </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">DefaultEditor::new()</span><span style="color:#adb7c9;">?</span><span style="color:#abb2bf;">;
</span></mark></td></tr><tr><td>16</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>17</td><td><span style="color:#abb2bf;">    </span><span style="font-style:italic;color:#5f697a;">// /tmp is a common place for temporary files and is writable by all users
</span></td></tr><tr><td><mark style="background-color:#8cc2fc0b;">18</mark></td><td><mark style="background-color:#8cc2fc0b;"><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> history_path </span><span style="color:#adb7c9;">= </span><span style="color:#9acc76;">&quot;/tmp/.minishell_history&quot;</span><span style="color:#abb2bf;">;
</span></mark></td></tr><tr><td>19</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>20</td><td><span style="color:#abb2bf;">    </span><span style="font-style:italic;color:#5f697a;">// Try to load existing history
</span></td></tr><tr><td><mark style="background-color:#8cc2fc0b;">21</mark></td><td><mark style="background-color:#8cc2fc0b;"><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">match</span><span style="color:#abb2bf;"> rl.</span><span style="color:#5ebfcc;">load_history</span><span style="color:#abb2bf;">(history_path) {
</span></mark></td></tr><tr><td>22</td><td><span style="color:#abb2bf;">        Ok(</span><span style="color:#adb7c9;">_</span><span style="color:#abb2bf;">) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{}
</span></td></tr><tr><td>23</td><td><span style="color:#abb2bf;">        Err(ReadlineError::Io(</span><span style="color:#adb7c9;">_</span><span style="color:#abb2bf;">)) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>24</td><td><span style="color:#abb2bf;">            </span><span style="font-style:italic;color:#5f697a;">// History file doesn&#39;t exist, create it
</span></td></tr><tr><td>25</td><td><span style="color:#abb2bf;">            fs::File::create(history_path)</span><span style="color:#adb7c9;">?</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>26</td><td><span style="color:#abb2bf;">        }
</span></td></tr><tr><td>27</td><td><span style="color:#abb2bf;">        Err(err) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>28</td><td><span style="color:#abb2bf;">            eprintln!(</span><span style="color:#9acc76;">&quot;minishell: Error loading history: </span><span style="color:#db9d63;">{}</span><span style="color:#9acc76;">&quot;</span><span style="color:#abb2bf;">, err);
</span></td></tr><tr><td>29</td><td><span style="color:#abb2bf;">        }
</span></td></tr><tr><td>30</td><td><span style="color:#abb2bf;">    }
</span></td></tr><tr><td>31</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>32</td><td><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">loop </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>33</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> line </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> rl.</span><span style="color:#5ebfcc;">readline</span><span style="color:#abb2bf;">(</span><span style="color:#9acc76;">&quot;&gt; &quot;</span><span style="color:#abb2bf;">);
</span></td></tr><tr><td>34</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>35</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">match</span><span style="color:#abb2bf;"> line {
</span></td></tr><tr><td>36</td><td><span style="color:#abb2bf;">            Ok(line) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>37</td><td><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> input </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> line.</span><span style="color:#5ebfcc;">trim</span><span style="color:#abb2bf;">();
</span></td></tr><tr><td>38</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>39</td><td><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">if</span><span style="color:#abb2bf;"> input.</span><span style="color:#5ebfcc;">is_empty</span><span style="color:#abb2bf;">() {
</span></td></tr><tr><td>40</td><td><span style="color:#abb2bf;">                    </span><span style="color:#cd74e8;">continue</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>41</td><td><span style="color:#abb2bf;">                }
</span></td></tr><tr><td>42</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>43</td><td><span style="color:#abb2bf;">                </span><span style="font-style:italic;color:#5f697a;">// Add command to history
</span></td></tr><tr><td><mark style="background-color:#8cc2fc0b;">44</mark></td><td><mark style="background-color:#8cc2fc0b;"><span style="color:#abb2bf;">                rl.</span><span style="color:#5ebfcc;">add_history_entry</span><span style="color:#abb2bf;">(input)</span><span style="color:#adb7c9;">?</span><span style="color:#abb2bf;">;
</span></mark></td></tr><tr><td>45</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>46</td><td><span style="color:#abb2bf;">                </span><span style="font-style:italic;color:#5f697a;">// rest of the code remains unchanged...
</span></td></tr><tr><td>47</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>48</td><td><span style="color:#abb2bf;">            }
</span></td></tr><tr><td>49</td><td><span style="color:#abb2bf;">            Err(e) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>50</td><td><span style="color:#abb2bf;">                eprintln!(</span><span style="color:#9acc76;">&quot;minishell: Error: </span><span style="color:#db9d63;">{:?}</span><span style="color:#9acc76;">&quot;</span><span style="color:#abb2bf;">, e);
</span></td></tr><tr><td>51</td><td><span style="color:#abb2bf;">            }
</span></td></tr><tr><td>52</td><td><span style="color:#abb2bf;">        }
</span></td></tr><tr><td>53</td><td><span style="color:#abb2bf;">    }
</span></td></tr><tr><td>54</td><td><span style="color:#abb2bf;">}
</span></td></tr></tbody></table></code></pre>
<p>One thing to note is that I elect to not save empty commands to the history,
so if the user just presses enter without typing anything, it will not be added,
which is a common behavior in many shells.</p>
<p>The history file is stored in <code>/tmp/.minishell_history</code>, which is loaded
when the shell starts and saved when the shell exits. This way, the user can
recall previous commands even after restarting the shell. We use the <code>tmp/</code>
directory as it is writable by all users (and thus we don't need to deal
with permission issues), and it is a common place for temporary files.</p>
<p>With our shell now supporting command history, we can use the up and down
arrow keys to navigate through previous commands, and we can use <code>Ctrl+R</code> to
search for previous commands.</p>
<section
  style="width: 100%; max-width: 100%; margin: 0 auto; text-align: center;">
  <img src="./images/reverse-cmd-search.png"  alt="Demonstration of reverse command search in a shell" 
    style="max-width: 100%; height: auto; display: inline-block;">
  
  <caption style="margin-top: 0.5em;">
    <p style="font-style: italic;">Reverse command search using `rustyline`</p>
  </caption>
  
</section>
<h3 id="signal-handling"><a class="zola-anchor" href="#signal-handling" aria-label="Anchor link for: signal-handling">Signal Handling</a></h3>
<p>Handling signals gracefully is very straightforward with <code>rustyline</code>. Right now,
if the user presses <code>Ctrl+C</code> (SIGINT) while the shell is running, it will just
display <code>"minishell: Error: Interrupted"</code>. Similarly for <code>Ctrl+D</code> (EOF), the
shell just displays <code>"minishell: Error: Eof"</code>.</p>
<p>To fix this, we'll adjust our match arms for matching the line input to handle
these signals more gracefully. Specifically, we want to exit the shell when
the user presses <code>Ctrl+C</code> or <code>Ctrl+D</code>, and we want to save the command history.
Similarly, when the user <code>exit</code>, we also want to save the command history before
exiting.</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#6c7079;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#cd74e8;">use </span><span style="color:#abb2bf;">rustyline::error::ReadlineError;
</span><span style="font-style:italic;color:#5f697a;">// other imports...
</span><span style="color:#abb2bf;">
</span><span style="color:#cd74e8;">fn </span><span style="color:#5cb3fa;">main</span><span style="color:#abb2bf;">() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
</span><span style="color:#abb2bf;">
</span><span style="color:#abb2bf;">    </span><span style="font-style:italic;color:#5f697a;">// same as before...
</span><span style="color:#abb2bf;">
</span><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">loop </span><span style="color:#abb2bf;">{
</span><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">match</span><span style="color:#abb2bf;"> line {
</span><span style="color:#abb2bf;">            Ok(line) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span><span style="color:#abb2bf;">                </span><span style="font-style:italic;color:#5f697a;">// ...
</span><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">while let </span><span style="color:#abb2bf;">Some(command) </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> commands.</span><span style="color:#5ebfcc;">next</span><span style="color:#abb2bf;">() {
</span><span style="color:#abb2bf;">                    </span><span style="font-style:italic;color:#5f697a;">// ...
</span><span style="color:#abb2bf;">                    </span><span style="color:#cd74e8;">match</span><span style="color:#abb2bf;"> command {
</span><span style="color:#abb2bf;">                        </span><span style="font-style:italic;color:#5f697a;">// ...
</span><span style="color:#abb2bf;">                        </span><span style="color:#9acc76;">&quot;exit&quot; </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span><span style="color:#abb2bf;">                            rl.</span><span style="color:#5ebfcc;">save_history</span><span style="color:#abb2bf;">(history_path)</span><span style="color:#adb7c9;">?</span><span style="color:#abb2bf;">;
</span><span style="color:#abb2bf;">                            </span><span style="color:#cd74e8;">return </span><span style="color:#abb2bf;">Ok(());
</span><span style="color:#abb2bf;">                        }
</span><span style="color:#abb2bf;">                        </span><span style="font-style:italic;color:#5f697a;">// ...
</span><span style="color:#abb2bf;">                    }
</span><span style="color:#abb2bf;">
</span><span style="color:#abb2bf;">            }
</span><span style="color:#abb2bf;">            Err(ReadlineError::Interrupted) </span><span style="color:#adb7c9;">| </span><span style="color:#abb2bf;">Err(ReadlineError::Eof) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span><span style="color:#abb2bf;">                </span><span style="font-style:italic;color:#5f697a;">// Handle Ctrl-C or Ctrl-D gracefully
</span><span style="color:#abb2bf;">                println!(</span><span style="color:#9acc76;">&quot;</span><span style="color:#5ebfcc;">\n</span><span style="color:#9acc76;">Exiting minishell...&quot;</span><span style="color:#abb2bf;">);
</span><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">break</span><span style="color:#abb2bf;">;
</span><span style="color:#abb2bf;">            }
</span><span style="color:#abb2bf;">            Err(e) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span><span style="color:#abb2bf;">                </span><span style="font-style:italic;color:#5f697a;">// unchanged from previous
</span><span style="color:#abb2bf;">                eprintln!(</span><span style="color:#9acc76;">&quot;minishell: Error: </span><span style="color:#db9d63;">{:?}</span><span style="color:#9acc76;">&quot;</span><span style="color:#abb2bf;">, e);
</span><span style="color:#abb2bf;">            }
</span><span style="color:#abb2bf;">        }
</span><span style="color:#abb2bf;">    }
</span><span style="color:#abb2bf;">
</span><span style="color:#abb2bf;">    </span><span style="font-style:italic;color:#5f697a;">// Save history and return Ok variant
</span><span style="color:#abb2bf;">    rl.</span><span style="color:#5ebfcc;">save_history</span><span style="color:#abb2bf;">(history_path)</span><span style="color:#adb7c9;">?</span><span style="color:#abb2bf;">;
</span><span style="color:#abb2bf;">    Ok(())
</span><span style="color:#abb2bf;">}
</span></code></pre>
<p>Now, when the user presses <code>Ctrl+C</code> or <code>Ctrl-D</code>, the shell will print a message
and exit gracefully, saving the command history to the specified file. Outside
of the main REPL loop, we added an <code>Ok(())</code> return type to the <code>main</code> function
to indicate that the shell exited successfully.</p>
<article class="note-container">
  <details open class="note-details">
    <summary class="note-header">
      
      <section class="note-icon">
        <p><code>rustyline</code> as a <em>line editor</em></p>

      </section>
      
    </summary>
    <section class="note-content">
      <p>When I said before that <code>rustyline</code> was a <strong>line editor</strong>, it probably didn't
make much sense. <em>What's the difference? I am still just inputting text on the
prompt line like before?</em></p>
<p>Well, now enter a string of commands like <code>ls -l | grep .rs | wc -l</code>, and then
press <code>Alt+B</code> to move the cursor backwards by a word, or <code>Ctrl+Left</code> to move
the cursor left by a word. You can also use <code>Ctrl+Right</code> to move the cursor
right by a word, and <code>Ctrl+A</code> to move the cursor to the beginning of the line,
and <code>Ctrl+E</code> to move it to the end of the line. These are just a few of the
many features that <code>rustyline</code> provides as a line editor.</p>
<p>Now you can easily edit your command line input, navigate through the
command history, and even search for previous commands using <code>Ctrl+R</code>!</p>

    </section>
  </details>
</article>
<hr />
<h2 id="bonus-greeting-message"><a class="zola-anchor" href="#bonus-greeting-message" aria-label="Anchor link for: bonus-greeting-message">Bonus: Greeting Message</a></h2>
<p>Before we finish, let's add a greeting message that displays when the shell
starts. I've always be a fan of the classic ASCII art logos that some shells
display (like at the start of an Apache Spark shell), so let's add a simple
ASCII art logo to our shell. We can use the <code>println!</code> macro to print a
multi-line string with the logo, and we can also print a welcome message to the
user:</p>
<pre data-lang="rust" style="background-color:#2b303b;color:#6c7079;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="font-style:italic;color:#5f697a;">// src/main.rs
</span><span style="color:#abb2bf;">
</span><span style="font-style:italic;color:#5f697a;">// ... (previous code)
</span><span style="color:#abb2bf;">
</span><span style="color:#cd74e8;">fn </span><span style="color:#5cb3fa;">main</span><span style="color:#abb2bf;">() -&gt; Result&lt;(), Boxdyn Error&gt; {
</span><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> rl </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">DefaultEditor::new()</span><span style="color:#adb7c9;">?</span><span style="color:#abb2bf;">;
</span><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> history_path </span><span style="color:#adb7c9;">= </span><span style="color:#9acc76;">&quot;/tmp/.minishell_history&quot;</span><span style="color:#abb2bf;">;
</span><span style="color:#abb2bf;">
</span><span style="color:#abb2bf;">    println!(
</span><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">r</span><span style="color:#9acc76;">&quot;
</span><span style="color:#9acc76;">  ___  ____       _     _          _ _
</span><span style="color:#9acc76;">  |  \/  (_)     (_)   | |        | | |
</span><span style="color:#9acc76;">  | .  . |_ _ __  _ ___| |__   ___| | |
</span><span style="color:#9acc76;">  | |\/| | | &#39;_ \| / __| &#39;_ \ / _ \ | |
</span><span style="color:#9acc76;">  | |  | | | | | | \__ \ | | |  __/ | |
</span><span style="color:#9acc76;">  \_|  |_/_|_| |_|_|___/_| |_|\___|_|_|
</span><span style="color:#9acc76;">&quot;
</span><span style="color:#abb2bf;">    );
</span><span style="color:#abb2bf;">    println!(</span><span style="color:#9acc76;">&quot; Welcome to minishell! Type &#39;exit&#39; to quit.</span><span style="color:#5ebfcc;">\n</span><span style="color:#9acc76;">&quot;</span><span style="color:#abb2bf;">);
</span><span style="color:#abb2bf;">
</span><span style="color:#abb2bf;">    </span><span style="font-style:italic;color:#5f697a;">// unchanged ...
</span><span style="color:#abb2bf;">
</span><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">loop </span><span style="color:#abb2bf;">{
</span><span style="color:#abb2bf;">        </span><span style="font-style:italic;color:#5f697a;">// rest of the code ...
</span><span style="color:#abb2bf;">    }
</span><span style="color:#abb2bf;">}
</span></code></pre>
<p>We escape the string with <code>r#"</code> to allow for multi-line "raw" strings without
escaping newlines or quotes. Now our shell will display a nice ASCII art logo
when it starts, along with a welcome message.</p>
<section
  style="width: 100%; max-width: 100%; margin: 0 auto; text-align: center;">
  <img src="./images/greeting.png"  alt="Greeting message with ASCII art logo" 
    style="max-width: 100%; height: auto; display: inline-block;">
  
  <caption style="margin-top: 0.5em;">
    <p style="font-style: italic;">Greeting message with ASCII art logo</p>
  </caption>
  
</section>
<p>You can explore some other cool ASCII logo graphics here if you want a different
logo: <a href="https://patorjk.com/software/taag/#p=display&amp;f=Slant&amp;t=minishell">Text to ASCII Generator</a>.</p>
<hr />
<h2 id="the-complete-script"><a class="zola-anchor" href="#the-complete-script" aria-label="Anchor link for: the-complete-script">The Complete Script</a></h2>
<p>Here is the complete code for our simple shell, which includes command history,
signal handling, and a greeting message. You can copy and paste this code into
your <code>src/main.rs</code> file to run the shell:</p>
<pre data-linenos data-lang="rust" style="background-color:#2b303b;color:#6c7079;" class="language-rust "><code class="language-rust" data-lang="rust"><table><tbody><tr><td>1</td><td><span style="color:#cd74e8;">use </span><span style="color:#abb2bf;">rustyline::error::ReadlineError;
</span></td></tr><tr><td>2</td><td><span style="color:#cd74e8;">use </span><span style="color:#abb2bf;">rustyline::DefaultEditor;
</span></td></tr><tr><td>3</td><td><span style="color:#cd74e8;">use </span><span style="color:#abb2bf;">std::{
</span></td></tr><tr><td>4</td><td><span style="color:#abb2bf;">    env,
</span></td></tr><tr><td>5</td><td><span style="color:#abb2bf;">    error::Error,
</span></td></tr><tr><td>6</td><td><span style="color:#abb2bf;">    fs,
</span></td></tr><tr><td>7</td><td><span style="color:#abb2bf;">    path::Path,
</span></td></tr><tr><td>8</td><td><span style="color:#abb2bf;">    process::{Child, Command, Stdio},
</span></td></tr><tr><td>9</td><td><span style="color:#abb2bf;">};
</span></td></tr><tr><td>10</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>11</td><td><span style="color:#cd74e8;">fn </span><span style="color:#5cb3fa;">main</span><span style="color:#abb2bf;">() -&gt; Result&lt;(), Boxdyn Error&gt; {
</span></td></tr><tr><td>12</td><td><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> rl </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">DefaultEditor::new()</span><span style="color:#adb7c9;">?</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>13</td><td><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> history_path </span><span style="color:#adb7c9;">= </span><span style="color:#9acc76;">&quot;/tmp/.minishell_history&quot;</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>14</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>15</td><td><span style="color:#abb2bf;">    println!(
</span></td></tr><tr><td>16</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">r</span><span style="color:#9acc76;">&quot;
</span></td></tr><tr><td>17</td><td><span style="color:#9acc76;">  ___  ____       _     _          _ _
</span></td></tr><tr><td>18</td><td><span style="color:#9acc76;">  |  \/  (_)     (_)   | |        | | |
</span></td></tr><tr><td>19</td><td><span style="color:#9acc76;">  | .  . |_ _ __  _ ___| |__   ___| | |
</span></td></tr><tr><td>20</td><td><span style="color:#9acc76;">  | |\/| | | &#39;_ \| / __| &#39;_ \ / _ \ | |
</span></td></tr><tr><td>21</td><td><span style="color:#9acc76;">  | |  | | | | | | \__ \ | | |  __/ | |
</span></td></tr><tr><td>22</td><td><span style="color:#9acc76;">  \_|  |_/_|_| |_|_|___/_| |_|\___|_|_|
</span></td></tr><tr><td>23</td><td><span style="color:#9acc76;">&quot;
</span></td></tr><tr><td>24</td><td><span style="color:#abb2bf;">    );
</span></td></tr><tr><td>25</td><td><span style="color:#abb2bf;">    println!(</span><span style="color:#9acc76;">&quot; Welcome to minishell! Type &#39;exit&#39; to quit.</span><span style="color:#5ebfcc;">\n</span><span style="color:#9acc76;">&quot;</span><span style="color:#abb2bf;">);
</span></td></tr><tr><td>26</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>27</td><td><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">match</span><span style="color:#abb2bf;"> rl.</span><span style="color:#5ebfcc;">load_history</span><span style="color:#abb2bf;">(history_path) {
</span></td></tr><tr><td>28</td><td><span style="color:#abb2bf;">        Ok(</span><span style="color:#adb7c9;">_</span><span style="color:#abb2bf;">) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{}
</span></td></tr><tr><td>29</td><td><span style="color:#abb2bf;">        Err(ReadlineError::Io(</span><span style="color:#adb7c9;">_</span><span style="color:#abb2bf;">)) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>30</td><td><span style="color:#abb2bf;">            fs::File::create(history_path)</span><span style="color:#adb7c9;">?</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>31</td><td><span style="color:#abb2bf;">        }
</span></td></tr><tr><td>32</td><td><span style="color:#abb2bf;">        Err(err) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>33</td><td><span style="color:#abb2bf;">            eprintln!(</span><span style="color:#9acc76;">&quot;minishell: Error loading history: </span><span style="color:#db9d63;">{}</span><span style="color:#9acc76;">&quot;</span><span style="color:#abb2bf;">, err);
</span></td></tr><tr><td>34</td><td><span style="color:#abb2bf;">        }
</span></td></tr><tr><td>35</td><td><span style="color:#abb2bf;">    }
</span></td></tr><tr><td>36</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>37</td><td><span style="color:#abb2bf;">    </span><span style="color:#cd74e8;">loop </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>38</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> line </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> rl.</span><span style="color:#5ebfcc;">readline</span><span style="color:#abb2bf;">(</span><span style="color:#9acc76;">&quot;&gt; &quot;</span><span style="color:#abb2bf;">);
</span></td></tr><tr><td>39</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>40</td><td><span style="color:#abb2bf;">        </span><span style="color:#cd74e8;">match</span><span style="color:#abb2bf;"> line {
</span></td></tr><tr><td>41</td><td><span style="color:#abb2bf;">            Ok(line) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>42</td><td><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> input </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> line.</span><span style="color:#5ebfcc;">trim</span><span style="color:#abb2bf;">();
</span></td></tr><tr><td>43</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>44</td><td><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">if</span><span style="color:#abb2bf;"> input.</span><span style="color:#5ebfcc;">is_empty</span><span style="color:#abb2bf;">() {
</span></td></tr><tr><td>45</td><td><span style="color:#abb2bf;">                    </span><span style="color:#cd74e8;">continue</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>46</td><td><span style="color:#abb2bf;">                }
</span></td></tr><tr><td>47</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>48</td><td><span style="color:#abb2bf;">                rl.</span><span style="color:#5ebfcc;">add_history_entry</span><span style="color:#abb2bf;">(input)</span><span style="color:#adb7c9;">?</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>49</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>50</td><td><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> commands </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> input.</span><span style="color:#5ebfcc;">trim</span><span style="color:#abb2bf;">().</span><span style="color:#5ebfcc;">split</span><span style="color:#abb2bf;">(</span><span style="color:#9acc76;">&quot; | &quot;</span><span style="color:#abb2bf;">).</span><span style="color:#5ebfcc;">peekable</span><span style="color:#abb2bf;">();
</span></td></tr><tr><td>51</td><td><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> prev_stdout </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">None;
</span></td></tr><tr><td>52</td><td><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> children: Vec&lt;Child&gt; </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">Vec::new();
</span></td></tr><tr><td>53</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>54</td><td><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">while let </span><span style="color:#abb2bf;">Some(command) </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> commands.</span><span style="color:#5ebfcc;">next</span><span style="color:#abb2bf;">() {
</span></td></tr><tr><td>55</td><td><span style="color:#abb2bf;">                    </span><span style="color:#cd74e8;">let mut</span><span style="color:#abb2bf;"> parts </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> command.</span><span style="color:#5ebfcc;">split_whitespace</span><span style="color:#abb2bf;">();
</span></td></tr><tr><td>56</td><td><span style="color:#abb2bf;">                    </span><span style="color:#cd74e8;">let </span><span style="color:#abb2bf;">Some(command) </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> parts.</span><span style="color:#5ebfcc;">next</span><span style="color:#abb2bf;">() </span><span style="color:#cd74e8;">else </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>57</td><td><span style="color:#abb2bf;">                        </span><span style="color:#cd74e8;">continue</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>58</td><td><span style="color:#abb2bf;">                    };
</span></td></tr><tr><td>59</td><td><span style="color:#abb2bf;">                    </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> args </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> parts;
</span></td></tr><tr><td>60</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>61</td><td><span style="color:#abb2bf;">                    </span><span style="color:#cd74e8;">match</span><span style="color:#abb2bf;"> command {
</span></td></tr><tr><td>62</td><td><span style="color:#abb2bf;">                        </span><span style="color:#9acc76;">&quot;cd&quot; </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>63</td><td><span style="color:#abb2bf;">                            </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> new_dir </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> args.</span><span style="color:#5ebfcc;">peekable</span><span style="color:#abb2bf;">().</span><span style="color:#5ebfcc;">peek</span><span style="color:#abb2bf;">().</span><span style="color:#5ebfcc;">map_or</span><span style="color:#abb2bf;">(</span><span style="color:#9acc76;">&quot;/&quot;</span><span style="color:#abb2bf;">, |</span><span style="color:#eb6772;">x</span><span style="color:#abb2bf;">| </span><span style="color:#adb7c9;">*</span><span style="color:#abb2bf;">x);
</span></td></tr><tr><td>64</td><td><span style="color:#abb2bf;">                            </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> root </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">Path::new(new_dir);
</span></td></tr><tr><td>65</td><td><span style="color:#abb2bf;">                            </span><span style="color:#cd74e8;">if let </span><span style="color:#abb2bf;">Err(e) </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">env::set_current_dir(root) {
</span></td></tr><tr><td>66</td><td><span style="color:#abb2bf;">                                eprintln!(</span><span style="color:#9acc76;">&quot;</span><span style="color:#db9d63;">{}</span><span style="color:#9acc76;">&quot;</span><span style="color:#abb2bf;">, e);
</span></td></tr><tr><td>67</td><td><span style="color:#abb2bf;">                            }
</span></td></tr><tr><td>68</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>69</td><td><span style="color:#abb2bf;">                            prev_stdout </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">None;
</span></td></tr><tr><td>70</td><td><span style="color:#abb2bf;">                        }
</span></td></tr><tr><td>71</td><td><span style="color:#abb2bf;">                        </span><span style="color:#9acc76;">&quot;exit&quot; </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>72</td><td><span style="color:#abb2bf;">                            rl.</span><span style="color:#5ebfcc;">save_history</span><span style="color:#abb2bf;">(history_path)</span><span style="color:#adb7c9;">?</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>73</td><td><span style="color:#abb2bf;">                            </span><span style="color:#cd74e8;">return </span><span style="color:#abb2bf;">Ok(());
</span></td></tr><tr><td>74</td><td><span style="color:#abb2bf;">                        }
</span></td></tr><tr><td>75</td><td><span style="color:#abb2bf;">                        command </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>76</td><td><span style="color:#abb2bf;">                            </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> stdin </span><span style="color:#adb7c9;">= </span><span style="color:#cd74e8;">match</span><span style="color:#abb2bf;"> prev_stdout.</span><span style="color:#5ebfcc;">take</span><span style="color:#abb2bf;">() {
</span></td></tr><tr><td>77</td><td><span style="color:#abb2bf;">                                Some(output) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">Stdio::from(output),
</span></td></tr><tr><td>78</td><td><span style="color:#abb2bf;">                                None </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">Stdio::inherit(),
</span></td></tr><tr><td>79</td><td><span style="color:#abb2bf;">                            };
</span></td></tr><tr><td>80</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>81</td><td><span style="color:#abb2bf;">                            </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> stdout </span><span style="color:#adb7c9;">= </span><span style="color:#cd74e8;">if</span><span style="color:#abb2bf;"> commands.</span><span style="color:#5ebfcc;">peek</span><span style="color:#abb2bf;">().</span><span style="color:#5ebfcc;">is_some</span><span style="color:#abb2bf;">() {
</span></td></tr><tr><td>82</td><td><span style="color:#abb2bf;">                                Stdio::piped()
</span></td></tr><tr><td>83</td><td><span style="color:#abb2bf;">                            } </span><span style="color:#cd74e8;">else </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>84</td><td><span style="color:#abb2bf;">                                Stdio::inherit()
</span></td></tr><tr><td>85</td><td><span style="color:#abb2bf;">                            };
</span></td></tr><tr><td>86</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>87</td><td><span style="color:#abb2bf;">                            </span><span style="color:#cd74e8;">let</span><span style="color:#abb2bf;"> child </span><span style="color:#adb7c9;">= </span><span style="color:#abb2bf;">Command::new(command)
</span></td></tr><tr><td>88</td><td><span style="color:#abb2bf;">                                .</span><span style="color:#5ebfcc;">args</span><span style="color:#abb2bf;">(args)
</span></td></tr><tr><td>89</td><td><span style="color:#abb2bf;">                                .</span><span style="color:#5ebfcc;">stdin</span><span style="color:#abb2bf;">(stdin)
</span></td></tr><tr><td>90</td><td><span style="color:#abb2bf;">                                .</span><span style="color:#5ebfcc;">stdout</span><span style="color:#abb2bf;">(stdout)
</span></td></tr><tr><td>91</td><td><span style="color:#abb2bf;">                                .</span><span style="color:#5ebfcc;">spawn</span><span style="color:#abb2bf;">();
</span></td></tr><tr><td>92</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>93</td><td><span style="color:#abb2bf;">                            </span><span style="color:#cd74e8;">match</span><span style="color:#abb2bf;"> child {
</span></td></tr><tr><td>94</td><td><span style="color:#abb2bf;">                                Ok(</span><span style="color:#cd74e8;">mut</span><span style="color:#abb2bf;"> child) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>95</td><td><span style="color:#abb2bf;">                                    prev_stdout </span><span style="color:#adb7c9;">=</span><span style="color:#abb2bf;"> child.stdout.</span><span style="color:#5ebfcc;">take</span><span style="color:#abb2bf;">();
</span></td></tr><tr><td>96</td><td><span style="color:#abb2bf;">                                    children.</span><span style="color:#5ebfcc;">push</span><span style="color:#abb2bf;">(child);
</span></td></tr><tr><td>97</td><td><span style="color:#abb2bf;">                                }
</span></td></tr><tr><td>98</td><td><span style="color:#abb2bf;">                                Err(e) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>99</td><td><span style="color:#abb2bf;">                                    eprintln!(</span><span style="color:#9acc76;">&quot;</span><span style="color:#db9d63;">{}</span><span style="color:#9acc76;">&quot;</span><span style="color:#abb2bf;">, e);
</span></td></tr><tr><td>100</td><td><span style="color:#abb2bf;">                                    </span><span style="color:#cd74e8;">break</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>101</td><td><span style="color:#abb2bf;">                                }
</span></td></tr><tr><td>102</td><td><span style="color:#abb2bf;">                            };
</span></td></tr><tr><td>103</td><td><span style="color:#abb2bf;">                        }
</span></td></tr><tr><td>104</td><td><span style="color:#abb2bf;">                    }
</span></td></tr><tr><td>105</td><td><span style="color:#abb2bf;">                }
</span></td></tr><tr><td>106</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>107</td><td><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">for mut</span><span style="color:#abb2bf;"> child </span><span style="color:#adb7c9;">in</span><span style="color:#abb2bf;"> children {
</span></td></tr><tr><td>108</td><td><span style="color:#abb2bf;">                    </span><span style="color:#cd74e8;">let </span><span style="color:#adb7c9;">_ =</span><span style="color:#abb2bf;"> child.</span><span style="color:#5ebfcc;">wait</span><span style="color:#abb2bf;">();
</span></td></tr><tr><td>109</td><td><span style="color:#abb2bf;">                }
</span></td></tr><tr><td>110</td><td><span style="color:#abb2bf;">            }
</span></td></tr><tr><td>111</td><td><span style="color:#abb2bf;">            Err(ReadlineError::Interrupted) </span><span style="color:#adb7c9;">| </span><span style="color:#abb2bf;">Err(ReadlineError::Eof) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>112</td><td><span style="color:#abb2bf;">                println!(</span><span style="color:#9acc76;">&quot;</span><span style="color:#5ebfcc;">\n</span><span style="color:#9acc76;">Exiting minishell...&quot;</span><span style="color:#abb2bf;">);
</span></td></tr><tr><td>113</td><td><span style="color:#abb2bf;">                </span><span style="color:#cd74e8;">break</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>114</td><td><span style="color:#abb2bf;">            }
</span></td></tr><tr><td>115</td><td><span style="color:#abb2bf;">            Err(e) </span><span style="color:#adb7c9;">=&gt; </span><span style="color:#abb2bf;">{
</span></td></tr><tr><td>116</td><td><span style="color:#abb2bf;">                eprintln!(</span><span style="color:#9acc76;">&quot;minishell: Error: </span><span style="color:#db9d63;">{:?}</span><span style="color:#9acc76;">&quot;</span><span style="color:#abb2bf;">, e);
</span></td></tr><tr><td>117</td><td><span style="color:#abb2bf;">            }
</span></td></tr><tr><td>118</td><td><span style="color:#abb2bf;">        }
</span></td></tr><tr><td>119</td><td><span style="color:#abb2bf;">    }
</span></td></tr><tr><td>120</td><td><span style="color:#abb2bf;">
</span></td></tr><tr><td>121</td><td><span style="color:#abb2bf;">    rl.</span><span style="color:#5ebfcc;">save_history</span><span style="color:#abb2bf;">(history_path)</span><span style="color:#adb7c9;">?</span><span style="color:#abb2bf;">;
</span></td></tr><tr><td>122</td><td><span style="color:#abb2bf;">    Ok(())
</span></td></tr><tr><td>123</td><td><span style="color:#abb2bf;">}
</span></td></tr></tbody></table></code></pre>
<hr />
<h2 id="final-word"><a class="zola-anchor" href="#final-word" aria-label="Anchor link for: final-word">Final Word</a></h2>
<p>Hopefully this post has given you a good overview of how to build a simple
shell in Rust. The complete, documented code is available on
<a href="https://github.com/micahkepe/minishell/tree/main">GitHub</a>. If you have any
questions or suggestions, feel free to reach out or open an issue on the
repository.</p>
<p>Even though our little shell is simple, it can be extended with more
features<sup class="footnote-reference"><a href="#2">2</a></sup> like syntax highlighting, command completion, custom configuration
files analogous to <code>.bashrc</code> or <code>.zshrc</code>, support for environment variables,
scripting, and more. It is left as an exercise for the reader to implement
these features. Feel free to fork the repository and add your own enhancements,
and if you do, I'd love to hear how you extended it!</p>
<hr />
<h2 id="footnotes"><a class="zola-anchor" href="#footnotes" aria-label="Anchor link for: footnotes">Footnotes</a></h2>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>This is a simplified version of the shell lifecycle. In reality, shells
may have more complex lifecycles, especially when dealing with job control,
background processes, and other advanced features.</p>
<p>While technically you could classify a shell as a <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a>
(Read-Eval-Print Loop), the term REPL is more commonly used in the context
of programming languages and interactive interpreters. A shell is more than
just a REPL since it interacts with the operating systems and provides a
more general command-line interface.</p>
<p>If you are interested in the intricacies of shells, I recommend checking out
the codebase of an existing shell, such as <a href="https://github.com/fish-shell/fish-shell">Fish</a>
(my personal favorite), which is has been <a href="https://github.com/fish-shell/fish-shell/pull/9512">rewritten entirely in
Rust</a>.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>For even more suggestions on features to add, see this <a href="https://www.cs.cornell.edu/courses/cs414/2004su/homework/shell/shell.html">assignment
description</a>
from Cornell's CS414 course (Operating Systems and Systems Programming). In
addition to another explanation and overview of shells, at the end of the
assignment description, there is a list of features that students can
optional implement to extend their shell. These features include things like
tab completion, advanced I/O redirection like <code>&gt;&amp;</code>, and more.</p>
</div>


        
    </article>

    <!-- Comment section -->
    
      
        
          <script
  src="https://giscus.app/client.js"
  data-repo="micahkepe&#x2F;blog"
  data-repo-id="R_kgDONfHznQ"
  data-category="General"
  data-category-id="DIC_kwDONfHznc4CnQJ4"
  data-mapping="pathname"
  data-strict="0"
  data-reactions-enabled="1"
  data-emit-metadata="0"
  data-input-position="bottom"

  
  data-theme="preferred_color_scheme"
  

  data-lang="en"
  data-loading="lazy"
  crossorigin="anonymous"
  async
></script>

        
      
    


    <!-- Page footer -->
    
    <footer>
        <hr>
        <p>
            
                Published by Micah Kepe
            
            
                
                in <a href="https://micahkepe.com/blog/categories/tutorial/">tutorial</a>
            
            
                and
                tagged
                
                    <a href="https://micahkepe.com/blog/tags/rust/">rust</a>
                    
                        
                            
                                and
                            
                        
                    
                
                    <a href="https://micahkepe.com/blog/tags/cli/">cli</a>
                    
                        
                    
                
            
        </p>

        <!-- Revision history (optional) -->
        
          
            
              
                
                
                <section class="revision-history">
                  <a href="https:&#x2F;&#x2F;github.com&#x2F;micahkepe&#x2F;blog&#x2F;commits&#x2F;main&#x2F;content&#x2F;minishell&#x2F;index.md" target="_blank" rel="noopener noreferrer">
                    (revision history)
                  </a>
                </section>
              
            
          
        

        
        
    </footer>


</article>


    </main>
    





  </body>
</html>
